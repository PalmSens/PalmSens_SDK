import abc
import typing

from System import (
    Array,
    Array_1,
    Attribute,
    Delegate,
    EventArgs,
    EventHandler,
    Exception,
    IDisposable,
    IServiceProvider,
)
from System.Collections import (
    ICollection,
    IComparer,
    IDictionary,
    IEnumerator,
    IList,
    ReadOnlyCollectionBase,
)
from System.Globalization import CultureInfo
from System.Reflection import MethodBase
from System.Runtime.InteropServices import ExternalException
from System.Runtime.Serialization import SerializationInfo, StreamingContext

class AttributeCollection(ICollection):
    def __init__(self, attributes: Array_1[Attribute]) -> None: ...
    Empty: AttributeCollection
    @property
    def Count(self) -> int: ...
    @property
    def Item(self) -> Attribute: ...
    @property
    def Item(self) -> Attribute: ...
    def CopyTo(self, array: Array, index: int) -> None: ...
    @staticmethod
    def FromExisting(
        existing: AttributeCollection, newAttributes: Array_1[Attribute]
    ) -> AttributeCollection: ...
    def GetEnumerator(self) -> IEnumerator: ...
    # Skipped Contains due to it being static, abstract and generic.

    Contains: Contains_MethodGroup
    class Contains_MethodGroup:
        @typing.overload
        def __call__(self, attributes: Array_1[Attribute]) -> bool: ...
        @typing.overload
        def __call__(self, attribute: Attribute) -> bool: ...

    # Skipped Matches due to it being static, abstract and generic.

    Matches: Matches_MethodGroup
    class Matches_MethodGroup:
        @typing.overload
        def __call__(self, attributes: Array_1[Attribute]) -> bool: ...
        @typing.overload
        def __call__(self, attribute: Attribute) -> bool: ...

class ComponentCollection(ReadOnlyCollectionBase):
    def __init__(self, components: Array_1[IComponent]) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def Item(self) -> IComponent: ...
    @property
    def Item(self) -> IComponent: ...
    def CopyTo(self, array: Array_1[IComponent], index: int) -> None: ...

class DefaultValueAttribute(Attribute):
    # Constructor .ctor(value : Int16) was skipped since it collides with above method
    # Constructor .ctor(value : Int32) was skipped since it collides with above method
    # Constructor .ctor(value : Int64) was skipped since it collides with above method
    # Constructor .ctor(value : Single) was skipped since it collides with above method
    # Constructor .ctor(value : Double) was skipped since it collides with above method
    # Constructor .ctor(value : Boolean) was skipped since it collides with above method
    # Constructor .ctor(value : String) was skipped since it collides with above method
    # Constructor .ctor(value : SByte) was skipped since it collides with above method
    # Constructor .ctor(value : UInt16) was skipped since it collides with above method
    # Constructor .ctor(value : UInt32) was skipped since it collides with above method
    # Constructor .ctor(value : UInt64) was skipped since it collides with above method
    @typing.overload
    def __init__(self, type: typing.Type[typing.Any], value: str) -> None: ...
    @typing.overload
    def __init__(self, value: str) -> None: ...
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: typing.Any) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...
    @property
    def Value(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...

class DesignerSerializationVisibility(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Hidden: DesignerSerializationVisibility  # 0
    Visible: DesignerSerializationVisibility  # 1
    Content: DesignerSerializationVisibility  # 2

class EditorBrowsableAttribute(Attribute):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, state: EditorBrowsableState) -> None: ...
    @property
    def State(self) -> EditorBrowsableState: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...

class EditorBrowsableState(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Always: EditorBrowsableState  # 0
    Never: EditorBrowsableState  # 1
    Advanced: EditorBrowsableState  # 2

class EventDescriptor(MemberDescriptor):
    @property
    def Attributes(self) -> AttributeCollection: ...
    @property
    def Category(self) -> str: ...
    @property
    def ComponentType(self) -> typing.Type[typing.Any]: ...
    @property
    def Description(self) -> str: ...
    @property
    def DesignTimeOnly(self) -> bool: ...
    @property
    def DisplayName(self) -> str: ...
    @property
    def EventType(self) -> typing.Type[typing.Any]: ...
    @property
    def IsBrowsable(self) -> bool: ...
    @property
    def IsMulticast(self) -> bool: ...
    @property
    def Name(self) -> str: ...
    @abc.abstractmethod
    def AddEventHandler(self, component: typing.Any, value: Delegate) -> None: ...
    @abc.abstractmethod
    def RemoveEventHandler(self, component: typing.Any, value: Delegate) -> None: ...

class EventDescriptorCollection(IList):
    @typing.overload
    def __init__(self, events: Array_1[EventDescriptor]) -> None: ...
    @typing.overload
    def __init__(self, events: Array_1[EventDescriptor], readOnly: bool) -> None: ...
    Empty: EventDescriptorCollection
    @property
    def Count(self) -> int: ...
    @Count.setter
    def Count(self, value: int) -> int: ...
    @property
    def Item(self) -> EventDescriptor: ...
    @property
    def Item(self) -> EventDescriptor: ...
    def Add(self, value: EventDescriptor) -> int: ...
    def Clear(self) -> None: ...
    def Contains(self, value: EventDescriptor) -> bool: ...
    def Find(self, name: str, ignoreCase: bool) -> EventDescriptor: ...
    def GetEnumerator(self) -> IEnumerator: ...
    def IndexOf(self, value: EventDescriptor) -> int: ...
    def Insert(self, index: int, value: EventDescriptor) -> None: ...
    def Remove(self, value: EventDescriptor) -> None: ...
    def RemoveAt(self, index: int) -> None: ...
    # Skipped Sort due to it being static, abstract and generic.

    Sort: Sort_MethodGroup
    class Sort_MethodGroup:
        @typing.overload
        def __call__(self) -> EventDescriptorCollection: ...
        @typing.overload
        def __call__(self, names: Array_1[str]) -> EventDescriptorCollection: ...
        @typing.overload
        def __call__(self, comparer: IComparer) -> EventDescriptorCollection: ...
        @typing.overload
        def __call__(
            self, names: Array_1[str], comparer: IComparer
        ) -> EventDescriptorCollection: ...

class IBindingList(IList, typing.Protocol):
    @property
    def AllowEdit(self) -> bool: ...
    @property
    def AllowNew(self) -> bool: ...
    @property
    def AllowRemove(self) -> bool: ...
    @property
    def IsSorted(self) -> bool: ...
    @property
    def SortDirection(self) -> ListSortDirection: ...
    @property
    def SortProperty(self) -> PropertyDescriptor: ...
    @property
    def SupportsChangeNotification(self) -> bool: ...
    @property
    def SupportsSearching(self) -> bool: ...
    @property
    def SupportsSorting(self) -> bool: ...
    @abc.abstractmethod
    def AddIndex(self, property: PropertyDescriptor) -> None: ...
    @abc.abstractmethod
    def AddNew(self) -> typing.Any: ...
    @abc.abstractmethod
    def ApplySort(self, property: PropertyDescriptor, direction: ListSortDirection) -> None: ...
    @abc.abstractmethod
    def Find(self, property: PropertyDescriptor, key: typing.Any) -> int: ...
    @abc.abstractmethod
    def RemoveIndex(self, property: PropertyDescriptor) -> None: ...
    @abc.abstractmethod
    def RemoveSort(self) -> None: ...

class IBindingListView(IBindingList, typing.Protocol):
    @property
    def Filter(self) -> str: ...
    @Filter.setter
    def Filter(self, value: str) -> str: ...
    @property
    def SortDescriptions(self) -> ListSortDescriptionCollection: ...
    @property
    def SupportsAdvancedSorting(self) -> bool: ...
    @property
    def SupportsFiltering(self) -> bool: ...
    @abc.abstractmethod
    def ApplySort(self, sorts: ListSortDescriptionCollection) -> None: ...
    @abc.abstractmethod
    def RemoveFilter(self) -> None: ...

class IComponent(IDisposable, typing.Protocol):
    @property
    def Site(self) -> ISite: ...
    @Site.setter
    def Site(self, value: ISite) -> ISite: ...

class IContainer(IDisposable, typing.Protocol):
    @property
    def Components(self) -> ComponentCollection: ...
    @abc.abstractmethod
    def Remove(self, component: IComponent) -> None: ...
    # Skipped Add due to it being static, abstract and generic.

    Add: Add_MethodGroup
    class Add_MethodGroup:
        @typing.overload
        def __call__(self, component: IComponent) -> None: ...
        @typing.overload
        def __call__(self, component: IComponent, name: str) -> None: ...

class ICustomTypeDescriptor(typing.Protocol):
    @abc.abstractmethod
    def GetAttributes(self) -> AttributeCollection: ...
    @abc.abstractmethod
    def GetClassName(self) -> str: ...
    @abc.abstractmethod
    def GetComponentName(self) -> str: ...
    @abc.abstractmethod
    def GetConverter(self) -> TypeConverter: ...
    @abc.abstractmethod
    def GetDefaultEvent(self) -> EventDescriptor: ...
    @abc.abstractmethod
    def GetDefaultProperty(self) -> PropertyDescriptor: ...
    @abc.abstractmethod
    def GetEditor(self, editorBaseType: typing.Type[typing.Any]) -> typing.Any: ...
    @abc.abstractmethod
    def GetPropertyOwner(self, pd: PropertyDescriptor) -> typing.Any: ...
    # Skipped GetEvents due to it being static, abstract and generic.

    GetEvents: GetEvents_MethodGroup
    class GetEvents_MethodGroup:
        @typing.overload
        def __call__(self) -> EventDescriptorCollection: ...
        @typing.overload
        def __call__(self, attributes: Array_1[Attribute]) -> EventDescriptorCollection: ...

    # Skipped GetProperties due to it being static, abstract and generic.

    GetProperties: GetProperties_MethodGroup
    class GetProperties_MethodGroup:
        @typing.overload
        def __call__(self) -> PropertyDescriptorCollection: ...
        @typing.overload
        def __call__(self, attributes: Array_1[Attribute]) -> PropertyDescriptorCollection: ...

class IDataErrorInfo(typing.Protocol):
    @property
    def Error(self) -> str: ...
    @property
    def Item(self) -> str: ...

class IEditableObject(typing.Protocol):
    @abc.abstractmethod
    def BeginEdit(self) -> None: ...
    @abc.abstractmethod
    def CancelEdit(self) -> None: ...
    @abc.abstractmethod
    def EndEdit(self) -> None: ...

class IListSource(typing.Protocol):
    @property
    def ContainsListCollection(self) -> bool: ...
    @abc.abstractmethod
    def GetList(self) -> IList: ...

class INotifyPropertyChanged(typing.Protocol):
    pass

class INotifyPropertyChanging(typing.Protocol):
    pass

class ISite(IServiceProvider, typing.Protocol):
    @property
    def Component(self) -> IComponent: ...
    @property
    def Container(self) -> IContainer: ...
    @property
    def DesignMode(self) -> bool: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...

class ISupportInitialize(typing.Protocol):
    @abc.abstractmethod
    def BeginInit(self) -> None: ...
    @abc.abstractmethod
    def EndInit(self) -> None: ...

class ISupportInitializeNotification(ISupportInitialize, typing.Protocol):
    @property
    def IsInitialized(self) -> bool: ...

class ITypeDescriptorContext(IServiceProvider, typing.Protocol):
    @property
    def Container(self) -> IContainer: ...
    @property
    def Instance(self) -> typing.Any: ...
    @property
    def PropertyDescriptor(self) -> PropertyDescriptor: ...
    @abc.abstractmethod
    def OnComponentChanged(self) -> None: ...
    @abc.abstractmethod
    def OnComponentChanging(self) -> bool: ...

class ITypedList(typing.Protocol):
    @abc.abstractmethod
    def GetItemProperties(
        self, listAccessors: Array_1[PropertyDescriptor]
    ) -> PropertyDescriptorCollection: ...
    @abc.abstractmethod
    def GetListName(self, listAccessors: Array_1[PropertyDescriptor]) -> str: ...

class ListSortDescription:
    def __init__(self, property: PropertyDescriptor, direction: ListSortDirection) -> None: ...
    @property
    def PropertyDescriptor(self) -> PropertyDescriptor: ...
    @PropertyDescriptor.setter
    def PropertyDescriptor(self, value: PropertyDescriptor) -> PropertyDescriptor: ...
    @property
    def SortDirection(self) -> ListSortDirection: ...
    @SortDirection.setter
    def SortDirection(self, value: ListSortDirection) -> ListSortDirection: ...

class ListSortDescriptionCollection(IList):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, sorts: Array_1[ListSortDescription]) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def Item(self) -> ListSortDescription: ...
    @Item.setter
    def Item(self, value: ListSortDescription) -> ListSortDescription: ...
    def Contains(self, value: typing.Any) -> bool: ...
    def CopyTo(self, array: Array, index: int) -> None: ...
    def IndexOf(self, value: typing.Any) -> int: ...

class ListSortDirection(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Ascending: ListSortDirection  # 0
    Descending: ListSortDirection  # 1

class MarshalByValueComponent(IComponent, IServiceProvider):
    def __init__(self) -> None: ...
    @property
    def Container(self) -> IContainer: ...
    @property
    def DesignMode(self) -> bool: ...
    @property
    def Site(self) -> ISite: ...
    @Site.setter
    def Site(self, value: ISite) -> ISite: ...
    def Dispose(self) -> None: ...
    def GetService(self, service: typing.Type[typing.Any]) -> typing.Any: ...
    def ToString(self) -> str: ...

class MemberDescriptor(abc.ABC):
    @property
    def Attributes(self) -> AttributeCollection: ...
    @property
    def Category(self) -> str: ...
    @property
    def Description(self) -> str: ...
    @property
    def DesignTimeOnly(self) -> bool: ...
    @property
    def DisplayName(self) -> str: ...
    @property
    def IsBrowsable(self) -> bool: ...
    @property
    def Name(self) -> str: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...

class PropertyChangedEventArgs(EventArgs):
    def __init__(self, propertyName: str) -> None: ...
    @property
    def PropertyName(self) -> str: ...

class PropertyDescriptor(MemberDescriptor):
    @property
    def Attributes(self) -> AttributeCollection: ...
    @property
    def Category(self) -> str: ...
    @property
    def ComponentType(self) -> typing.Type[typing.Any]: ...
    @property
    def Converter(self) -> TypeConverter: ...
    @property
    def Description(self) -> str: ...
    @property
    def DesignTimeOnly(self) -> bool: ...
    @property
    def DisplayName(self) -> str: ...
    @property
    def IsBrowsable(self) -> bool: ...
    @property
    def IsLocalizable(self) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def Name(self) -> str: ...
    @property
    def PropertyType(self) -> typing.Type[typing.Any]: ...
    @property
    def SerializationVisibility(self) -> DesignerSerializationVisibility: ...
    @property
    def SupportsChangeEvents(self) -> bool: ...
    def AddValueChanged(self, component: typing.Any, handler: EventHandler) -> None: ...
    @abc.abstractmethod
    def CanResetValue(self, component: typing.Any) -> bool: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetEditor(self, editorBaseType: typing.Type[typing.Any]) -> typing.Any: ...
    def GetHashCode(self) -> int: ...
    @abc.abstractmethod
    def GetValue(self, component: typing.Any) -> typing.Any: ...
    def RemoveValueChanged(self, component: typing.Any, handler: EventHandler) -> None: ...
    @abc.abstractmethod
    def ResetValue(self, component: typing.Any) -> None: ...
    @abc.abstractmethod
    def SetValue(self, component: typing.Any, value: typing.Any) -> None: ...
    @abc.abstractmethod
    def ShouldSerializeValue(self, component: typing.Any) -> bool: ...
    # Skipped GetChildProperties due to it being static, abstract and generic.

    GetChildProperties: GetChildProperties_MethodGroup
    class GetChildProperties_MethodGroup:
        @typing.overload
        def __call__(self) -> PropertyDescriptorCollection: ...
        @typing.overload
        def __call__(self, filter: Array_1[Attribute]) -> PropertyDescriptorCollection: ...
        @typing.overload
        def __call__(self, instance: typing.Any) -> PropertyDescriptorCollection: ...
        @typing.overload
        def __call__(
            self, instance: typing.Any, filter: Array_1[Attribute]
        ) -> PropertyDescriptorCollection: ...

class PropertyDescriptorCollection(IDictionary, IList):
    @typing.overload
    def __init__(self, properties: Array_1[PropertyDescriptor]) -> None: ...
    @typing.overload
    def __init__(self, properties: Array_1[PropertyDescriptor], readOnly: bool) -> None: ...
    Empty: PropertyDescriptorCollection
    @property
    def Count(self) -> int: ...
    @Count.setter
    def Count(self, value: int) -> int: ...
    @property
    def Item(self) -> PropertyDescriptor: ...
    @property
    def Item(self) -> PropertyDescriptor: ...
    def Add(self, value: PropertyDescriptor) -> int: ...
    def Clear(self) -> None: ...
    def Contains(self, value: PropertyDescriptor) -> bool: ...
    def CopyTo(self, array: Array, index: int) -> None: ...
    def Find(self, name: str, ignoreCase: bool) -> PropertyDescriptor: ...
    def GetEnumerator(self) -> IEnumerator: ...
    def IndexOf(self, value: PropertyDescriptor) -> int: ...
    def Insert(self, index: int, value: PropertyDescriptor) -> None: ...
    def Remove(self, value: PropertyDescriptor) -> None: ...
    def RemoveAt(self, index: int) -> None: ...
    # Skipped Sort due to it being static, abstract and generic.

    Sort: Sort_MethodGroup
    class Sort_MethodGroup:
        @typing.overload
        def __call__(self) -> PropertyDescriptorCollection: ...
        @typing.overload
        def __call__(self, names: Array_1[str]) -> PropertyDescriptorCollection: ...
        @typing.overload
        def __call__(self, comparer: IComparer) -> PropertyDescriptorCollection: ...
        @typing.overload
        def __call__(
            self, names: Array_1[str], comparer: IComparer
        ) -> PropertyDescriptorCollection: ...

class TypeConverter:
    def __init__(self) -> None: ...

    class StandardValuesCollection(ICollection):
        def __init__(self, values: ICollection) -> None: ...
        @property
        def Count(self) -> int: ...
        @property
        def Item(self) -> typing.Any: ...
        def CopyTo(self, array: Array, index: int) -> None: ...
        def GetEnumerator(self) -> IEnumerator: ...

    # Skipped CanConvertFrom due to it being static, abstract and generic.

    CanConvertFrom: CanConvertFrom_MethodGroup
    class CanConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, sourceType: typing.Type[typing.Any]) -> bool: ...
        @typing.overload
        def __call__(
            self, context: ITypeDescriptorContext, sourceType: typing.Type[typing.Any]
        ) -> bool: ...

    # Skipped CanConvertTo due to it being static, abstract and generic.

    CanConvertTo: CanConvertTo_MethodGroup
    class CanConvertTo_MethodGroup:
        @typing.overload
        def __call__(self, destinationType: typing.Type[typing.Any]) -> bool: ...
        @typing.overload
        def __call__(
            self, context: ITypeDescriptorContext, destinationType: typing.Type[typing.Any]
        ) -> bool: ...

    # Skipped ConvertFrom due to it being static, abstract and generic.

    ConvertFrom: ConvertFrom_MethodGroup
    class ConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> typing.Any: ...
        @typing.overload
        def __call__(
            self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any
        ) -> typing.Any: ...

    # Skipped ConvertFromInvariantString due to it being static, abstract and generic.

    ConvertFromInvariantString: ConvertFromInvariantString_MethodGroup
    class ConvertFromInvariantString_MethodGroup:
        @typing.overload
        def __call__(self, text: str) -> typing.Any: ...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, text: str) -> typing.Any: ...

    # Skipped ConvertFromString due to it being static, abstract and generic.

    ConvertFromString: ConvertFromString_MethodGroup
    class ConvertFromString_MethodGroup:
        @typing.overload
        def __call__(self, text: str) -> typing.Any: ...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, text: str) -> typing.Any: ...
        @typing.overload
        def __call__(
            self, context: ITypeDescriptorContext, culture: CultureInfo, text: str
        ) -> typing.Any: ...

    # Skipped ConvertTo due to it being static, abstract and generic.

    ConvertTo: ConvertTo_MethodGroup
    class ConvertTo_MethodGroup:
        @typing.overload
        def __call__(
            self, value: typing.Any, destinationType: typing.Type[typing.Any]
        ) -> typing.Any: ...
        @typing.overload
        def __call__(
            self,
            context: ITypeDescriptorContext,
            culture: CultureInfo,
            value: typing.Any,
            destinationType: typing.Type[typing.Any],
        ) -> typing.Any: ...

    # Skipped ConvertToInvariantString due to it being static, abstract and generic.

    ConvertToInvariantString: ConvertToInvariantString_MethodGroup
    class ConvertToInvariantString_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> str: ...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, value: typing.Any) -> str: ...

    # Skipped ConvertToString due to it being static, abstract and generic.

    ConvertToString: ConvertToString_MethodGroup
    class ConvertToString_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> str: ...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, value: typing.Any) -> str: ...
        @typing.overload
        def __call__(
            self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any
        ) -> str: ...

    # Skipped CreateInstance due to it being static, abstract and generic.

    CreateInstance: CreateInstance_MethodGroup
    class CreateInstance_MethodGroup:
        @typing.overload
        def __call__(self, propertyValues: IDictionary) -> typing.Any: ...
        @typing.overload
        def __call__(
            self, context: ITypeDescriptorContext, propertyValues: IDictionary
        ) -> typing.Any: ...

    # Skipped GetCreateInstanceSupported due to it being static, abstract and generic.

    GetCreateInstanceSupported: GetCreateInstanceSupported_MethodGroup
    class GetCreateInstanceSupported_MethodGroup:
        @typing.overload
        def __call__(self) -> bool: ...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> bool: ...

    # Skipped GetProperties due to it being static, abstract and generic.

    GetProperties: GetProperties_MethodGroup
    class GetProperties_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> PropertyDescriptorCollection: ...
        @typing.overload
        def __call__(
            self, context: ITypeDescriptorContext, value: typing.Any
        ) -> PropertyDescriptorCollection: ...
        @typing.overload
        def __call__(
            self,
            context: ITypeDescriptorContext,
            value: typing.Any,
            attributes: Array_1[Attribute],
        ) -> PropertyDescriptorCollection: ...

    # Skipped GetPropertiesSupported due to it being static, abstract and generic.

    GetPropertiesSupported: GetPropertiesSupported_MethodGroup
    class GetPropertiesSupported_MethodGroup:
        @typing.overload
        def __call__(self) -> bool: ...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> bool: ...

    # Skipped GetStandardValues due to it being static, abstract and generic.

    GetStandardValues: GetStandardValues_MethodGroup
    class GetStandardValues_MethodGroup:
        @typing.overload
        def __call__(self) -> ICollection: ...
        @typing.overload
        def __call__(
            self, context: ITypeDescriptorContext
        ) -> TypeConverter.StandardValuesCollection: ...

    # Skipped GetStandardValuesExclusive due to it being static, abstract and generic.

    GetStandardValuesExclusive: GetStandardValuesExclusive_MethodGroup
    class GetStandardValuesExclusive_MethodGroup:
        @typing.overload
        def __call__(self) -> bool: ...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> bool: ...

    # Skipped GetStandardValuesSupported due to it being static, abstract and generic.

    GetStandardValuesSupported: GetStandardValuesSupported_MethodGroup
    class GetStandardValuesSupported_MethodGroup:
        @typing.overload
        def __call__(self) -> bool: ...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> bool: ...

    # Skipped IsValid due to it being static, abstract and generic.

    IsValid: IsValid_MethodGroup
    class IsValid_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> bool: ...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, value: typing.Any) -> bool: ...

class Win32Exception(ExternalException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, error: int) -> None: ...
    @typing.overload
    def __init__(self, error: int, message: str) -> None: ...
    @typing.overload
    def __init__(self, message: str) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: Exception) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def ErrorCode(self) -> int: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def NativeErrorCode(self) -> int: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def ToString(self) -> str: ...
