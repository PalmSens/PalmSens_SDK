import abc
import typing

from System import (
    Array,
    Array_1,
    AsyncCallback,
    Converter_2,
    DateTime,
    Decimal,
    EventArgs,
    Exception,
    Guid,
    IAsyncResult,
    IDisposable,
    MulticastDelegate,
)
from System.Collections import Hashtable, ICollection, IEnumerator
from System.ComponentModel import (
    IBindingList,
    IBindingListView,
    IContainer,
    ICustomTypeDescriptor,
    IDataErrorInfo,
    IEditableObject,
    IListSource,
    INotifyPropertyChanged,
    ISite,
    ISupportInitializeNotification,
    ITypedList,
    MarshalByValueComponent,
)
from System.Data.Common import DbDataReader
from System.Globalization import CultureInfo
from System.IO import Stream, TextReader, TextWriter
from System.Reflection import MethodInfo
from System.Runtime.Serialization import ISerializable, SerializationInfo, StreamingContext
from System.Xml import XmlReader, XmlWriter
from System.Xml.Schema import XmlSchemaComplexType, XmlSchemaSet
from System.Xml.Serialization import IXmlSerializable

class AcceptRejectRule(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    None_: AcceptRejectRule  # 0
    Cascade: AcceptRejectRule  # 1

class Constraint(abc.ABC):
    @property
    def ConstraintName(self) -> str: ...
    @ConstraintName.setter
    def ConstraintName(self, value: str) -> str: ...
    @property
    def ExtendedProperties(self) -> PropertyCollection: ...
    @property
    def Table(self) -> DataTable: ...
    def ToString(self) -> str: ...

class ConstraintCollection(InternalDataCollectionBase):
    @property
    def Count(self) -> int: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def IsSynchronized(self) -> bool: ...
    @property
    def Item(self) -> Constraint: ...
    @property
    def Item(self) -> Constraint: ...
    @property
    def SyncRoot(self) -> typing.Any: ...
    def AddRange(self, constraints: Array_1[Constraint]) -> None: ...
    def CanRemove(self, constraint: Constraint) -> bool: ...
    def Clear(self) -> None: ...
    def Contains(self, name: str) -> bool: ...
    def CopyTo(self, array: Array_1[Constraint], index: int) -> None: ...
    def RemoveAt(self, index: int) -> None: ...
    # Skipped Add due to it being static, abstract and generic.

    Add: Add_MethodGroup
    class Add_MethodGroup:
        @typing.overload
        def __call__(self, constraint: Constraint) -> None: ...
        @typing.overload
        def __call__(
            self,
            name: str,
            primaryKeyColumns: Array_1[DataColumn],
            foreignKeyColumns: Array_1[DataColumn],
        ) -> Constraint: ...
        @typing.overload
        def __call__(
            self, name: str, columns: Array_1[DataColumn], primaryKey: bool
        ) -> Constraint: ...
        @typing.overload
        def __call__(
            self, name: str, primaryKeyColumn: DataColumn, foreignKeyColumn: DataColumn
        ) -> Constraint: ...
        @typing.overload
        def __call__(self, name: str, column: DataColumn, primaryKey: bool) -> Constraint: ...

    # Skipped IndexOf due to it being static, abstract and generic.

    IndexOf: IndexOf_MethodGroup
    class IndexOf_MethodGroup:
        @typing.overload
        def __call__(self, constraintName: str) -> int: ...
        @typing.overload
        def __call__(self, constraint: Constraint) -> int: ...

    # Skipped Remove due to it being static, abstract and generic.

    Remove: Remove_MethodGroup
    class Remove_MethodGroup:
        @typing.overload
        def __call__(self, name: str) -> None: ...
        @typing.overload
        def __call__(self, constraint: Constraint) -> None: ...

class DataColumn(MarshalByValueComponent):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, columnName: str) -> None: ...
    @typing.overload
    def __init__(self, columnName: str, dataType: typing.Type[typing.Any]) -> None: ...
    @typing.overload
    def __init__(
        self, columnName: str, dataType: typing.Type[typing.Any], expr: str
    ) -> None: ...
    @typing.overload
    def __init__(
        self, columnName: str, dataType: typing.Type[typing.Any], expr: str, type: MappingType
    ) -> None: ...
    @property
    def AllowDBNull(self) -> bool: ...
    @AllowDBNull.setter
    def AllowDBNull(self, value: bool) -> bool: ...
    @property
    def AutoIncrement(self) -> bool: ...
    @AutoIncrement.setter
    def AutoIncrement(self, value: bool) -> bool: ...
    @property
    def AutoIncrementSeed(self) -> int: ...
    @AutoIncrementSeed.setter
    def AutoIncrementSeed(self, value: int) -> int: ...
    @property
    def AutoIncrementStep(self) -> int: ...
    @AutoIncrementStep.setter
    def AutoIncrementStep(self, value: int) -> int: ...
    @property
    def Caption(self) -> str: ...
    @Caption.setter
    def Caption(self, value: str) -> str: ...
    @property
    def ColumnMapping(self) -> MappingType: ...
    @ColumnMapping.setter
    def ColumnMapping(self, value: MappingType) -> MappingType: ...
    @property
    def ColumnName(self) -> str: ...
    @ColumnName.setter
    def ColumnName(self, value: str) -> str: ...
    @property
    def Container(self) -> IContainer: ...
    @property
    def DataType(self) -> typing.Type[typing.Any]: ...
    @DataType.setter
    def DataType(self, value: typing.Type[typing.Any]) -> typing.Type[typing.Any]: ...
    @property
    def DateTimeMode(self) -> DataSetDateTime: ...
    @DateTimeMode.setter
    def DateTimeMode(self, value: DataSetDateTime) -> DataSetDateTime: ...
    @property
    def DefaultValue(self) -> typing.Any: ...
    @DefaultValue.setter
    def DefaultValue(self, value: typing.Any) -> typing.Any: ...
    @property
    def DesignMode(self) -> bool: ...
    @property
    def Expression(self) -> str: ...
    @Expression.setter
    def Expression(self, value: str) -> str: ...
    @property
    def ExtendedProperties(self) -> PropertyCollection: ...
    @property
    def MaxLength(self) -> int: ...
    @MaxLength.setter
    def MaxLength(self, value: int) -> int: ...
    @property
    def Namespace(self) -> str: ...
    @Namespace.setter
    def Namespace(self, value: str) -> str: ...
    @property
    def Ordinal(self) -> int: ...
    @property
    def Prefix(self) -> str: ...
    @Prefix.setter
    def Prefix(self, value: str) -> str: ...
    @property
    def ReadOnly(self) -> bool: ...
    @ReadOnly.setter
    def ReadOnly(self, value: bool) -> bool: ...
    @property
    def Site(self) -> ISite: ...
    @Site.setter
    def Site(self, value: ISite) -> ISite: ...
    @property
    def Table(self) -> DataTable: ...
    @property
    def Unique(self) -> bool: ...
    @Unique.setter
    def Unique(self, value: bool) -> bool: ...
    def SetOrdinal(self, ordinal: int) -> None: ...
    def ToString(self) -> str: ...

class DataColumnCollection(InternalDataCollectionBase):
    @property
    def Count(self) -> int: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def IsSynchronized(self) -> bool: ...
    @property
    def Item(self) -> DataColumn: ...
    @property
    def Item(self) -> DataColumn: ...
    @property
    def SyncRoot(self) -> typing.Any: ...
    def AddRange(self, columns: Array_1[DataColumn]) -> None: ...
    def CanRemove(self, column: DataColumn) -> bool: ...
    def Clear(self) -> None: ...
    def Contains(self, name: str) -> bool: ...
    def CopyTo(self, array: Array_1[DataColumn], index: int) -> None: ...
    def RemoveAt(self, index: int) -> None: ...
    # Skipped Add due to it being static, abstract and generic.

    Add: Add_MethodGroup
    class Add_MethodGroup:
        @typing.overload
        def __call__(self) -> DataColumn: ...
        @typing.overload
        def __call__(self, column: DataColumn) -> None: ...
        @typing.overload
        def __call__(self, columnName: str) -> DataColumn: ...
        @typing.overload
        def __call__(self, columnName: str, type: typing.Type[typing.Any]) -> DataColumn: ...
        @typing.overload
        def __call__(
            self, columnName: str, type: typing.Type[typing.Any], expression: str
        ) -> DataColumn: ...

    # Skipped IndexOf due to it being static, abstract and generic.

    IndexOf: IndexOf_MethodGroup
    class IndexOf_MethodGroup:
        @typing.overload
        def __call__(self, column: DataColumn) -> int: ...
        @typing.overload
        def __call__(self, columnName: str) -> int: ...

    # Skipped Remove due to it being static, abstract and generic.

    Remove: Remove_MethodGroup
    class Remove_MethodGroup:
        @typing.overload
        def __call__(self, column: DataColumn) -> None: ...
        @typing.overload
        def __call__(self, name: str) -> None: ...

class DataRelation:
    @typing.overload
    def __init__(
        self, relationName: str, parentColumn: DataColumn, childColumn: DataColumn
    ) -> None: ...
    @typing.overload
    def __init__(
        self,
        relationName: str,
        parentColumn: DataColumn,
        childColumn: DataColumn,
        createConstraints: bool,
    ) -> None: ...
    @typing.overload
    def __init__(
        self,
        relationName: str,
        parentColumns: Array_1[DataColumn],
        childColumns: Array_1[DataColumn],
    ) -> None: ...
    @typing.overload
    def __init__(
        self,
        relationName: str,
        parentColumns: Array_1[DataColumn],
        childColumns: Array_1[DataColumn],
        createConstraints: bool,
    ) -> None: ...
    @typing.overload
    def __init__(
        self,
        relationName: str,
        parentTableName: str,
        childTableName: str,
        parentColumnNames: Array_1[str],
        childColumnNames: Array_1[str],
        nested: bool,
    ) -> None: ...
    @typing.overload
    def __init__(
        self,
        relationName: str,
        parentTableName: str,
        parentTableNamespace: str,
        childTableName: str,
        childTableNamespace: str,
        parentColumnNames: Array_1[str],
        childColumnNames: Array_1[str],
        nested: bool,
    ) -> None: ...
    @property
    def ChildColumns(self) -> Array_1[DataColumn]: ...
    @property
    def ChildKeyConstraint(self) -> ForeignKeyConstraint: ...
    @property
    def ChildTable(self) -> DataTable: ...
    @property
    def DataSet(self) -> DataSet: ...
    @property
    def ExtendedProperties(self) -> PropertyCollection: ...
    @property
    def Nested(self) -> bool: ...
    @Nested.setter
    def Nested(self, value: bool) -> bool: ...
    @property
    def ParentColumns(self) -> Array_1[DataColumn]: ...
    @property
    def ParentKeyConstraint(self) -> UniqueConstraint: ...
    @property
    def ParentTable(self) -> DataTable: ...
    @property
    def RelationName(self) -> str: ...
    @RelationName.setter
    def RelationName(self, value: str) -> str: ...
    def ToString(self) -> str: ...

class DataRelationCollection(InternalDataCollectionBase, abc.ABC):
    @property
    def Count(self) -> int: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def IsSynchronized(self) -> bool: ...
    @property
    def Item(self) -> DataRelation: ...
    @property
    def Item(self) -> DataRelation: ...
    @property
    def SyncRoot(self) -> typing.Any: ...
    def AddRange(self, relations: Array_1[DataRelation]) -> None: ...
    def CanRemove(self, relation: DataRelation) -> bool: ...
    def Clear(self) -> None: ...
    def Contains(self, name: str) -> bool: ...
    def CopyTo(self, array: Array_1[DataRelation], index: int) -> None: ...
    def RemoveAt(self, index: int) -> None: ...
    # Skipped Add due to it being static, abstract and generic.

    Add: Add_MethodGroup
    class Add_MethodGroup:
        @typing.overload
        def __call__(self, relation: DataRelation) -> None: ...
        @typing.overload
        def __call__(
            self, parentColumns: Array_1[DataColumn], childColumns: Array_1[DataColumn]
        ) -> DataRelation: ...
        @typing.overload
        def __call__(
            self, parentColumn: DataColumn, childColumn: DataColumn
        ) -> DataRelation: ...
        @typing.overload
        def __call__(
            self,
            name: str,
            parentColumns: Array_1[DataColumn],
            childColumns: Array_1[DataColumn],
        ) -> DataRelation: ...
        @typing.overload
        def __call__(
            self, name: str, parentColumn: DataColumn, childColumn: DataColumn
        ) -> DataRelation: ...
        @typing.overload
        def __call__(
            self,
            name: str,
            parentColumns: Array_1[DataColumn],
            childColumns: Array_1[DataColumn],
            createConstraints: bool,
        ) -> DataRelation: ...
        @typing.overload
        def __call__(
            self,
            name: str,
            parentColumn: DataColumn,
            childColumn: DataColumn,
            createConstraints: bool,
        ) -> DataRelation: ...

    # Skipped IndexOf due to it being static, abstract and generic.

    IndexOf: IndexOf_MethodGroup
    class IndexOf_MethodGroup:
        @typing.overload
        def __call__(self, relationName: str) -> int: ...
        @typing.overload
        def __call__(self, relation: DataRelation) -> int: ...

    # Skipped Remove due to it being static, abstract and generic.

    Remove: Remove_MethodGroup
    class Remove_MethodGroup:
        @typing.overload
        def __call__(self, name: str) -> None: ...
        @typing.overload
        def __call__(self, relation: DataRelation) -> None: ...

class DataRow:
    @property
    def HasErrors(self) -> bool: ...
    @property
    def Item(self) -> typing.Any: ...
    @Item.setter
    def Item(self, value: typing.Any) -> typing.Any: ...
    @property
    def Item(self) -> typing.Any: ...
    @Item.setter
    def Item(self, value: typing.Any) -> typing.Any: ...
    @property
    def Item(self) -> typing.Any: ...
    @Item.setter
    def Item(self, value: typing.Any) -> typing.Any: ...
    @property
    def Item(self) -> typing.Any: ...
    @property
    def Item(self) -> typing.Any: ...
    @property
    def Item(self) -> typing.Any: ...
    @property
    def ItemArray(self) -> Array_1[typing.Any]: ...
    @ItemArray.setter
    def ItemArray(self, value: Array_1[typing.Any]) -> Array_1[typing.Any]: ...
    @property
    def RowError(self) -> str: ...
    @RowError.setter
    def RowError(self, value: str) -> str: ...
    @property
    def RowState(self) -> DataRowState: ...
    @property
    def Table(self) -> DataTable: ...
    def AcceptChanges(self) -> None: ...
    def BeginEdit(self) -> None: ...
    def CancelEdit(self) -> None: ...
    def ClearErrors(self) -> None: ...
    def Delete(self) -> None: ...
    def EndEdit(self) -> None: ...
    def GetColumnsInError(self) -> Array_1[DataColumn]: ...
    def HasVersion(self, version: DataRowVersion) -> bool: ...
    def RejectChanges(self) -> None: ...
    def SetAdded(self) -> None: ...
    def SetModified(self) -> None: ...
    # Skipped GetChildRows due to it being static, abstract and generic.

    GetChildRows: GetChildRows_MethodGroup
    class GetChildRows_MethodGroup:
        @typing.overload
        def __call__(self, relationName: str) -> Array_1[DataRow]: ...
        @typing.overload
        def __call__(self, relation: DataRelation) -> Array_1[DataRow]: ...
        @typing.overload
        def __call__(self, relationName: str, version: DataRowVersion) -> Array_1[DataRow]: ...
        @typing.overload
        def __call__(
            self, relation: DataRelation, version: DataRowVersion
        ) -> Array_1[DataRow]: ...

    # Skipped GetColumnError due to it being static, abstract and generic.

    GetColumnError: GetColumnError_MethodGroup
    class GetColumnError_MethodGroup:
        @typing.overload
        def __call__(self, columnIndex: int) -> str: ...
        @typing.overload
        def __call__(self, column: DataColumn) -> str: ...
        @typing.overload
        def __call__(self, columnName: str) -> str: ...

    # Skipped GetParentRow due to it being static, abstract and generic.

    GetParentRow: GetParentRow_MethodGroup
    class GetParentRow_MethodGroup:
        @typing.overload
        def __call__(self, relationName: str) -> DataRow: ...
        @typing.overload
        def __call__(self, relation: DataRelation) -> DataRow: ...
        @typing.overload
        def __call__(self, relationName: str, version: DataRowVersion) -> DataRow: ...
        @typing.overload
        def __call__(self, relation: DataRelation, version: DataRowVersion) -> DataRow: ...

    # Skipped GetParentRows due to it being static, abstract and generic.

    GetParentRows: GetParentRows_MethodGroup
    class GetParentRows_MethodGroup:
        @typing.overload
        def __call__(self, relationName: str) -> Array_1[DataRow]: ...
        @typing.overload
        def __call__(self, relation: DataRelation) -> Array_1[DataRow]: ...
        @typing.overload
        def __call__(self, relationName: str, version: DataRowVersion) -> Array_1[DataRow]: ...
        @typing.overload
        def __call__(
            self, relation: DataRelation, version: DataRowVersion
        ) -> Array_1[DataRow]: ...

    # Skipped IsNull due to it being static, abstract and generic.

    IsNull: IsNull_MethodGroup
    class IsNull_MethodGroup:
        @typing.overload
        def __call__(self, columnIndex: int) -> bool: ...
        @typing.overload
        def __call__(self, column: DataColumn) -> bool: ...
        @typing.overload
        def __call__(self, columnName: str) -> bool: ...
        @typing.overload
        def __call__(self, column: DataColumn, version: DataRowVersion) -> bool: ...

    # Skipped SetColumnError due to it being static, abstract and generic.

    SetColumnError: SetColumnError_MethodGroup
    class SetColumnError_MethodGroup:
        @typing.overload
        def __call__(self, columnIndex: int, error: str) -> None: ...
        @typing.overload
        def __call__(self, column: DataColumn, error: str) -> None: ...
        @typing.overload
        def __call__(self, columnName: str, error: str) -> None: ...

    # Skipped SetParentRow due to it being static, abstract and generic.

    SetParentRow: SetParentRow_MethodGroup
    class SetParentRow_MethodGroup:
        @typing.overload
        def __call__(self, parentRow: DataRow) -> None: ...
        @typing.overload
        def __call__(self, parentRow: DataRow, relation: DataRelation) -> None: ...

class DataRowCollection(InternalDataCollectionBase):
    @property
    def Count(self) -> int: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def IsSynchronized(self) -> bool: ...
    @property
    def Item(self) -> DataRow: ...
    @property
    def SyncRoot(self) -> typing.Any: ...
    def Clear(self) -> None: ...
    def GetEnumerator(self) -> IEnumerator: ...
    def IndexOf(self, row: DataRow) -> int: ...
    def InsertAt(self, row: DataRow, pos: int) -> None: ...
    def Remove(self, row: DataRow) -> None: ...
    def RemoveAt(self, index: int) -> None: ...
    # Skipped Add due to it being static, abstract and generic.

    Add: Add_MethodGroup
    class Add_MethodGroup:
        @typing.overload
        def __call__(self, values: Array_1[typing.Any]) -> DataRow: ...
        @typing.overload
        def __call__(self, row: DataRow) -> None: ...

    # Skipped Contains due to it being static, abstract and generic.

    Contains: Contains_MethodGroup
    class Contains_MethodGroup:
        @typing.overload
        def __call__(self, keys: Array_1[typing.Any]) -> bool: ...
        @typing.overload
        def __call__(self, key: typing.Any) -> bool: ...

    # Skipped CopyTo due to it being static, abstract and generic.

    CopyTo: CopyTo_MethodGroup
    class CopyTo_MethodGroup:
        @typing.overload
        def __call__(self, array: Array_1[DataRow], index: int) -> None: ...
        @typing.overload
        def __call__(self, ar: Array, index: int) -> None: ...

    # Skipped Find due to it being static, abstract and generic.

    Find: Find_MethodGroup
    class Find_MethodGroup:
        @typing.overload
        def __call__(self, keys: Array_1[typing.Any]) -> DataRow: ...
        @typing.overload
        def __call__(self, key: typing.Any) -> DataRow: ...

class DataRowState(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Detached: DataRowState  # 1
    Unchanged: DataRowState  # 2
    Added: DataRowState  # 4
    Deleted: DataRowState  # 8
    Modified: DataRowState  # 16

class DataRowVersion(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Original: DataRowVersion  # 256
    Current: DataRowVersion  # 512
    Proposed: DataRowVersion  # 1024
    Default: DataRowVersion  # 1536

class DataRowView(
    INotifyPropertyChanged, IDataErrorInfo, IEditableObject, ICustomTypeDescriptor
):
    @property
    def DataView(self) -> DataView: ...
    @property
    def IsEdit(self) -> bool: ...
    @property
    def IsNew(self) -> bool: ...
    @property
    def Item(self) -> typing.Any: ...
    @Item.setter
    def Item(self, value: typing.Any) -> typing.Any: ...
    @property
    def Item(self) -> typing.Any: ...
    @Item.setter
    def Item(self, value: typing.Any) -> typing.Any: ...
    @property
    def Row(self) -> DataRow: ...
    @property
    def RowVersion(self) -> DataRowVersion: ...
    def BeginEdit(self) -> None: ...
    def CancelEdit(self) -> None: ...
    def Delete(self) -> None: ...
    def EndEdit(self) -> None: ...
    def Equals(self, other: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    # Skipped CreateChildView due to it being static, abstract and generic.

    CreateChildView: CreateChildView_MethodGroup
    class CreateChildView_MethodGroup:
        @typing.overload
        def __call__(self, relationName: str) -> DataView: ...
        @typing.overload
        def __call__(self, relation: DataRelation) -> DataView: ...
        @typing.overload
        def __call__(self, relationName: str, followParent: bool) -> DataView: ...
        @typing.overload
        def __call__(self, relation: DataRelation, followParent: bool) -> DataView: ...

class DataSet(
    MarshalByValueComponent,
    ISupportInitializeNotification,
    ISerializable,
    IXmlSerializable,
    IListSource,
):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, dataSetName: str) -> None: ...
    @property
    def CaseSensitive(self) -> bool: ...
    @CaseSensitive.setter
    def CaseSensitive(self, value: bool) -> bool: ...
    @property
    def Container(self) -> IContainer: ...
    @property
    def DataSetName(self) -> str: ...
    @DataSetName.setter
    def DataSetName(self, value: str) -> str: ...
    @property
    def DefaultViewManager(self) -> DataViewManager: ...
    @property
    def DesignMode(self) -> bool: ...
    @property
    def EnforceConstraints(self) -> bool: ...
    @EnforceConstraints.setter
    def EnforceConstraints(self, value: bool) -> bool: ...
    @property
    def ExtendedProperties(self) -> PropertyCollection: ...
    @property
    def HasErrors(self) -> bool: ...
    @property
    def IsInitialized(self) -> bool: ...
    @property
    def Locale(self) -> CultureInfo: ...
    @Locale.setter
    def Locale(self, value: CultureInfo) -> CultureInfo: ...
    @property
    def Namespace(self) -> str: ...
    @Namespace.setter
    def Namespace(self, value: str) -> str: ...
    @property
    def Prefix(self) -> str: ...
    @Prefix.setter
    def Prefix(self, value: str) -> str: ...
    @property
    def Relations(self) -> DataRelationCollection: ...
    @property
    def RemotingFormat(self) -> SerializationFormat: ...
    @RemotingFormat.setter
    def RemotingFormat(self, value: SerializationFormat) -> SerializationFormat: ...
    @property
    def SchemaSerializationMode(self) -> SchemaSerializationMode: ...
    @SchemaSerializationMode.setter
    def SchemaSerializationMode(
        self, value: SchemaSerializationMode
    ) -> SchemaSerializationMode: ...
    @property
    def Site(self) -> ISite: ...
    @Site.setter
    def Site(self, value: ISite) -> ISite: ...
    @property
    def Tables(self) -> DataTableCollection: ...
    def AcceptChanges(self) -> None: ...
    def BeginInit(self) -> None: ...
    def Clear(self) -> None: ...
    def Clone(self) -> DataSet: ...
    def Copy(self) -> DataSet: ...
    def EndInit(self) -> None: ...
    @staticmethod
    def GetDataSetSchema(schemaSet: XmlSchemaSet) -> XmlSchemaComplexType: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetXml(self) -> str: ...
    def GetXmlSchema(self) -> str: ...
    def RejectChanges(self) -> None: ...
    def Reset(self) -> None: ...
    # Skipped CreateDataReader due to it being static, abstract and generic.

    CreateDataReader: CreateDataReader_MethodGroup
    class CreateDataReader_MethodGroup:
        @typing.overload
        def __call__(self) -> DataTableReader: ...
        @typing.overload
        def __call__(self, dataTables: Array_1[DataTable]) -> DataTableReader: ...

    # Skipped GetChanges due to it being static, abstract and generic.

    GetChanges: GetChanges_MethodGroup
    class GetChanges_MethodGroup:
        @typing.overload
        def __call__(self) -> DataSet: ...
        @typing.overload
        def __call__(self, rowStates: DataRowState) -> DataSet: ...

    # Skipped HasChanges due to it being static, abstract and generic.

    HasChanges: HasChanges_MethodGroup
    class HasChanges_MethodGroup:
        @typing.overload
        def __call__(self) -> bool: ...
        @typing.overload
        def __call__(self, rowStates: DataRowState) -> bool: ...

    # Skipped InferXmlSchema due to it being static, abstract and generic.

    InferXmlSchema: InferXmlSchema_MethodGroup
    class InferXmlSchema_MethodGroup:
        @typing.overload
        def __call__(self, fileName: str, nsArray: Array_1[str]) -> None: ...
        @typing.overload
        def __call__(self, reader: TextReader, nsArray: Array_1[str]) -> None: ...
        @typing.overload
        def __call__(self, stream: Stream, nsArray: Array_1[str]) -> None: ...
        @typing.overload
        def __call__(self, reader: XmlReader, nsArray: Array_1[str]) -> None: ...

    # Skipped Load due to it being static, abstract and generic.

    Load: Load_MethodGroup
    class Load_MethodGroup:
        @typing.overload
        def __call__(
            self, reader: IDataReader, loadOption: LoadOption, tables: Array_1[DataTable]
        ) -> None: ...
        @typing.overload
        def __call__(
            self, reader: IDataReader, loadOption: LoadOption, tables: Array_1[str]
        ) -> None: ...
        @typing.overload
        def __call__(
            self,
            reader: IDataReader,
            loadOption: LoadOption,
            errorHandler: FillErrorEventHandler,
            tables: Array_1[DataTable],
        ) -> None: ...

    # Skipped Merge due to it being static, abstract and generic.

    Merge: Merge_MethodGroup
    class Merge_MethodGroup:
        @typing.overload
        def __call__(self, rows: Array_1[DataRow]) -> None: ...
        @typing.overload
        def __call__(self, dataSet: DataSet) -> None: ...
        @typing.overload
        def __call__(self, table: DataTable) -> None: ...
        @typing.overload
        def __call__(self, dataSet: DataSet, preserveChanges: bool) -> None: ...
        @typing.overload
        def __call__(
            self,
            rows: Array_1[DataRow],
            preserveChanges: bool,
            missingSchemaAction: MissingSchemaAction,
        ) -> None: ...
        @typing.overload
        def __call__(
            self,
            dataSet: DataSet,
            preserveChanges: bool,
            missingSchemaAction: MissingSchemaAction,
        ) -> None: ...
        @typing.overload
        def __call__(
            self,
            table: DataTable,
            preserveChanges: bool,
            missingSchemaAction: MissingSchemaAction,
        ) -> None: ...

    # Skipped ReadXml due to it being static, abstract and generic.

    ReadXml: ReadXml_MethodGroup
    class ReadXml_MethodGroup:
        @typing.overload
        def __call__(self, fileName: str) -> XmlReadMode: ...
        @typing.overload
        def __call__(self, reader: TextReader) -> XmlReadMode: ...
        @typing.overload
        def __call__(self, stream: Stream) -> XmlReadMode: ...
        @typing.overload
        def __call__(self, reader: XmlReader) -> XmlReadMode: ...
        @typing.overload
        def __call__(self, fileName: str, mode: XmlReadMode) -> XmlReadMode: ...
        @typing.overload
        def __call__(self, reader: TextReader, mode: XmlReadMode) -> XmlReadMode: ...
        @typing.overload
        def __call__(self, stream: Stream, mode: XmlReadMode) -> XmlReadMode: ...
        @typing.overload
        def __call__(self, reader: XmlReader, mode: XmlReadMode) -> XmlReadMode: ...

    # Skipped ReadXmlSchema due to it being static, abstract and generic.

    ReadXmlSchema: ReadXmlSchema_MethodGroup
    class ReadXmlSchema_MethodGroup:
        @typing.overload
        def __call__(self, fileName: str) -> None: ...
        @typing.overload
        def __call__(self, reader: TextReader) -> None: ...
        @typing.overload
        def __call__(self, stream: Stream) -> None: ...
        @typing.overload
        def __call__(self, reader: XmlReader) -> None: ...

    # Skipped WriteXml due to it being static, abstract and generic.

    WriteXml: WriteXml_MethodGroup
    class WriteXml_MethodGroup:
        @typing.overload
        def __call__(self, fileName: str) -> None: ...
        @typing.overload
        def __call__(self, stream: Stream) -> None: ...
        @typing.overload
        def __call__(self, writer: TextWriter) -> None: ...
        @typing.overload
        def __call__(self, writer: XmlWriter) -> None: ...
        @typing.overload
        def __call__(self, fileName: str, mode: XmlWriteMode) -> None: ...
        @typing.overload
        def __call__(self, stream: Stream, mode: XmlWriteMode) -> None: ...
        @typing.overload
        def __call__(self, writer: TextWriter, mode: XmlWriteMode) -> None: ...
        @typing.overload
        def __call__(self, writer: XmlWriter, mode: XmlWriteMode) -> None: ...

    # Skipped WriteXmlSchema due to it being static, abstract and generic.

    WriteXmlSchema: WriteXmlSchema_MethodGroup
    class WriteXmlSchema_MethodGroup:
        @typing.overload
        def __call__(self, fileName: str) -> None: ...
        @typing.overload
        def __call__(self, stream: Stream) -> None: ...
        @typing.overload
        def __call__(self, writer: TextWriter) -> None: ...
        @typing.overload
        def __call__(self, writer: XmlWriter) -> None: ...
        @typing.overload
        def __call__(
            self,
            fileName: str,
            multipleTargetConverter: Converter_2[typing.Type[typing.Any], str],
        ) -> None: ...
        @typing.overload
        def __call__(
            self,
            stream: Stream,
            multipleTargetConverter: Converter_2[typing.Type[typing.Any], str],
        ) -> None: ...
        @typing.overload
        def __call__(
            self,
            writer: TextWriter,
            multipleTargetConverter: Converter_2[typing.Type[typing.Any], str],
        ) -> None: ...
        @typing.overload
        def __call__(
            self,
            writer: XmlWriter,
            multipleTargetConverter: Converter_2[typing.Type[typing.Any], str],
        ) -> None: ...

class DataSetDateTime(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Local: DataSetDateTime  # 1
    Unspecified: DataSetDateTime  # 2
    UnspecifiedLocal: DataSetDateTime  # 3
    Utc: DataSetDateTime  # 4

class DataTable(
    MarshalByValueComponent,
    ISupportInitializeNotification,
    IXmlSerializable,
    ISerializable,
    IListSource,
):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, tableName: str) -> None: ...
    @typing.overload
    def __init__(self, tableName: str, tableNamespace: str) -> None: ...
    @property
    def CaseSensitive(self) -> bool: ...
    @CaseSensitive.setter
    def CaseSensitive(self, value: bool) -> bool: ...
    @property
    def ChildRelations(self) -> DataRelationCollection: ...
    @property
    def Columns(self) -> DataColumnCollection: ...
    @property
    def Constraints(self) -> ConstraintCollection: ...
    @property
    def Container(self) -> IContainer: ...
    @property
    def DataSet(self) -> DataSet: ...
    @property
    def DefaultView(self) -> DataView: ...
    @property
    def DesignMode(self) -> bool: ...
    @property
    def DisplayExpression(self) -> str: ...
    @DisplayExpression.setter
    def DisplayExpression(self, value: str) -> str: ...
    @property
    def ExtendedProperties(self) -> PropertyCollection: ...
    @property
    def HasErrors(self) -> bool: ...
    @property
    def IsInitialized(self) -> bool: ...
    @property
    def Locale(self) -> CultureInfo: ...
    @Locale.setter
    def Locale(self, value: CultureInfo) -> CultureInfo: ...
    @property
    def MinimumCapacity(self) -> int: ...
    @MinimumCapacity.setter
    def MinimumCapacity(self, value: int) -> int: ...
    @property
    def Namespace(self) -> str: ...
    @Namespace.setter
    def Namespace(self, value: str) -> str: ...
    @property
    def ParentRelations(self) -> DataRelationCollection: ...
    @property
    def Prefix(self) -> str: ...
    @Prefix.setter
    def Prefix(self, value: str) -> str: ...
    @property
    def PrimaryKey(self) -> Array_1[DataColumn]: ...
    @PrimaryKey.setter
    def PrimaryKey(self, value: Array_1[DataColumn]) -> Array_1[DataColumn]: ...
    @property
    def RemotingFormat(self) -> SerializationFormat: ...
    @RemotingFormat.setter
    def RemotingFormat(self, value: SerializationFormat) -> SerializationFormat: ...
    @property
    def Rows(self) -> DataRowCollection: ...
    @property
    def Site(self) -> ISite: ...
    @Site.setter
    def Site(self, value: ISite) -> ISite: ...
    @property
    def TableName(self) -> str: ...
    @TableName.setter
    def TableName(self, value: str) -> str: ...
    def AcceptChanges(self) -> None: ...
    def BeginInit(self) -> None: ...
    def BeginLoadData(self) -> None: ...
    def Clear(self) -> None: ...
    def Clone(self) -> DataTable: ...
    def Compute(self, expression: str, filter: str) -> typing.Any: ...
    def Copy(self) -> DataTable: ...
    def CreateDataReader(self) -> DataTableReader: ...
    def EndInit(self) -> None: ...
    def EndLoadData(self) -> None: ...
    @staticmethod
    def GetDataTableSchema(schemaSet: XmlSchemaSet) -> XmlSchemaComplexType: ...
    def GetErrors(self) -> Array_1[DataRow]: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def ImportRow(self, row: DataRow) -> None: ...
    def NewRow(self) -> DataRow: ...
    def RejectChanges(self) -> None: ...
    def Reset(self) -> None: ...
    def ToString(self) -> str: ...
    # Skipped GetChanges due to it being static, abstract and generic.

    GetChanges: GetChanges_MethodGroup
    class GetChanges_MethodGroup:
        @typing.overload
        def __call__(self) -> DataTable: ...
        @typing.overload
        def __call__(self, rowStates: DataRowState) -> DataTable: ...

    # Skipped Load due to it being static, abstract and generic.

    Load: Load_MethodGroup
    class Load_MethodGroup:
        @typing.overload
        def __call__(self, reader: IDataReader) -> None: ...
        @typing.overload
        def __call__(self, reader: IDataReader, loadOption: LoadOption) -> None: ...
        @typing.overload
        def __call__(
            self,
            reader: IDataReader,
            loadOption: LoadOption,
            errorHandler: FillErrorEventHandler,
        ) -> None: ...

    # Skipped LoadDataRow due to it being static, abstract and generic.

    LoadDataRow: LoadDataRow_MethodGroup
    class LoadDataRow_MethodGroup:
        @typing.overload
        def __call__(self, values: Array_1[typing.Any], loadOption: LoadOption) -> DataRow: ...
        @typing.overload
        def __call__(self, values: Array_1[typing.Any], fAcceptChanges: bool) -> DataRow: ...

    # Skipped Merge due to it being static, abstract and generic.

    Merge: Merge_MethodGroup
    class Merge_MethodGroup:
        @typing.overload
        def __call__(self, table: DataTable) -> None: ...
        @typing.overload
        def __call__(self, table: DataTable, preserveChanges: bool) -> None: ...
        @typing.overload
        def __call__(
            self,
            table: DataTable,
            preserveChanges: bool,
            missingSchemaAction: MissingSchemaAction,
        ) -> None: ...

    # Skipped ReadXml due to it being static, abstract and generic.

    ReadXml: ReadXml_MethodGroup
    class ReadXml_MethodGroup:
        @typing.overload
        def __call__(self, fileName: str) -> XmlReadMode: ...
        @typing.overload
        def __call__(self, reader: TextReader) -> XmlReadMode: ...
        @typing.overload
        def __call__(self, stream: Stream) -> XmlReadMode: ...
        @typing.overload
        def __call__(self, reader: XmlReader) -> XmlReadMode: ...

    # Skipped ReadXmlSchema due to it being static, abstract and generic.

    ReadXmlSchema: ReadXmlSchema_MethodGroup
    class ReadXmlSchema_MethodGroup:
        @typing.overload
        def __call__(self, fileName: str) -> None: ...
        @typing.overload
        def __call__(self, reader: TextReader) -> None: ...
        @typing.overload
        def __call__(self, stream: Stream) -> None: ...
        @typing.overload
        def __call__(self, reader: XmlReader) -> None: ...

    # Skipped Select due to it being static, abstract and generic.

    Select: Select_MethodGroup
    class Select_MethodGroup:
        @typing.overload
        def __call__(self) -> Array_1[DataRow]: ...
        @typing.overload
        def __call__(self, filterExpression: str) -> Array_1[DataRow]: ...
        @typing.overload
        def __call__(self, filterExpression: str, sort: str) -> Array_1[DataRow]: ...
        @typing.overload
        def __call__(
            self, filterExpression: str, sort: str, recordStates: DataViewRowState
        ) -> Array_1[DataRow]: ...

    # Skipped WriteXml due to it being static, abstract and generic.

    WriteXml: WriteXml_MethodGroup
    class WriteXml_MethodGroup:
        @typing.overload
        def __call__(self, fileName: str) -> None: ...
        @typing.overload
        def __call__(self, stream: Stream) -> None: ...
        @typing.overload
        def __call__(self, writer: TextWriter) -> None: ...
        @typing.overload
        def __call__(self, writer: XmlWriter) -> None: ...
        @typing.overload
        def __call__(self, fileName: str, mode: XmlWriteMode) -> None: ...
        @typing.overload
        def __call__(self, stream: Stream, mode: XmlWriteMode) -> None: ...
        @typing.overload
        def __call__(self, writer: TextWriter, mode: XmlWriteMode) -> None: ...
        @typing.overload
        def __call__(self, fileName: str, writeHierarchy: bool) -> None: ...
        @typing.overload
        def __call__(self, stream: Stream, writeHierarchy: bool) -> None: ...
        @typing.overload
        def __call__(self, writer: TextWriter, writeHierarchy: bool) -> None: ...
        @typing.overload
        def __call__(self, writer: XmlWriter, mode: XmlWriteMode) -> None: ...
        @typing.overload
        def __call__(self, writer: XmlWriter, writeHierarchy: bool) -> None: ...
        @typing.overload
        def __call__(self, fileName: str, mode: XmlWriteMode, writeHierarchy: bool) -> None: ...
        @typing.overload
        def __call__(
            self, stream: Stream, mode: XmlWriteMode, writeHierarchy: bool
        ) -> None: ...
        @typing.overload
        def __call__(
            self, writer: TextWriter, mode: XmlWriteMode, writeHierarchy: bool
        ) -> None: ...
        @typing.overload
        def __call__(
            self, writer: XmlWriter, mode: XmlWriteMode, writeHierarchy: bool
        ) -> None: ...

    # Skipped WriteXmlSchema due to it being static, abstract and generic.

    WriteXmlSchema: WriteXmlSchema_MethodGroup
    class WriteXmlSchema_MethodGroup:
        @typing.overload
        def __call__(self, fileName: str) -> None: ...
        @typing.overload
        def __call__(self, stream: Stream) -> None: ...
        @typing.overload
        def __call__(self, writer: TextWriter) -> None: ...
        @typing.overload
        def __call__(self, writer: XmlWriter) -> None: ...
        @typing.overload
        def __call__(self, fileName: str, writeHierarchy: bool) -> None: ...
        @typing.overload
        def __call__(self, stream: Stream, writeHierarchy: bool) -> None: ...
        @typing.overload
        def __call__(self, writer: TextWriter, writeHierarchy: bool) -> None: ...
        @typing.overload
        def __call__(self, writer: XmlWriter, writeHierarchy: bool) -> None: ...

class DataTableCollection(InternalDataCollectionBase):
    @property
    def Count(self) -> int: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def IsSynchronized(self) -> bool: ...
    @property
    def Item(self) -> DataTable: ...
    @property
    def Item(self) -> DataTable: ...
    @property
    def Item(self) -> DataTable: ...
    @property
    def SyncRoot(self) -> typing.Any: ...
    def AddRange(self, tables: Array_1[DataTable]) -> None: ...
    def CanRemove(self, table: DataTable) -> bool: ...
    def Clear(self) -> None: ...
    def CopyTo(self, array: Array_1[DataTable], index: int) -> None: ...
    def RemoveAt(self, index: int) -> None: ...
    # Skipped Add due to it being static, abstract and generic.

    Add: Add_MethodGroup
    class Add_MethodGroup:
        @typing.overload
        def __call__(self) -> DataTable: ...
        @typing.overload
        def __call__(self, table: DataTable) -> None: ...
        @typing.overload
        def __call__(self, name: str) -> DataTable: ...
        @typing.overload
        def __call__(self, name: str, tableNamespace: str) -> DataTable: ...

    # Skipped Contains due to it being static, abstract and generic.

    Contains: Contains_MethodGroup
    class Contains_MethodGroup:
        @typing.overload
        def __call__(self, name: str) -> bool: ...
        @typing.overload
        def __call__(self, name: str, tableNamespace: str) -> bool: ...

    # Skipped IndexOf due to it being static, abstract and generic.

    IndexOf: IndexOf_MethodGroup
    class IndexOf_MethodGroup:
        @typing.overload
        def __call__(self, table: DataTable) -> int: ...
        @typing.overload
        def __call__(self, tableName: str) -> int: ...
        @typing.overload
        def __call__(self, tableName: str, tableNamespace: str) -> int: ...

    # Skipped Remove due to it being static, abstract and generic.

    Remove: Remove_MethodGroup
    class Remove_MethodGroup:
        @typing.overload
        def __call__(self, table: DataTable) -> None: ...
        @typing.overload
        def __call__(self, name: str) -> None: ...
        @typing.overload
        def __call__(self, name: str, tableNamespace: str) -> None: ...

class DataTableReader(DbDataReader):
    @typing.overload
    def __init__(self, dataTable: DataTable) -> None: ...
    @typing.overload
    def __init__(self, dataTables: Array_1[DataTable]) -> None: ...
    @property
    def Depth(self) -> int: ...
    @property
    def FieldCount(self) -> int: ...
    @property
    def HasRows(self) -> bool: ...
    @property
    def IsClosed(self) -> bool: ...
    @property
    def Item(self) -> typing.Any: ...
    @property
    def Item(self) -> typing.Any: ...
    @property
    def RecordsAffected(self) -> int: ...
    @property
    def VisibleFieldCount(self) -> int: ...
    def Close(self) -> None: ...
    def GetBoolean(self, ordinal: int) -> bool: ...
    def GetByte(self, ordinal: int) -> int: ...
    def GetBytes(
        self, ordinal: int, dataIndex: int, buffer: Array_1[int], bufferIndex: int, length: int
    ) -> int: ...
    def GetChar(self, ordinal: int) -> str: ...
    def GetChars(
        self, ordinal: int, dataIndex: int, buffer: Array_1[str], bufferIndex: int, length: int
    ) -> int: ...
    def GetDataTypeName(self, ordinal: int) -> str: ...
    def GetDateTime(self, ordinal: int) -> DateTime: ...
    def GetDecimal(self, ordinal: int) -> Decimal: ...
    def GetDouble(self, ordinal: int) -> float: ...
    def GetEnumerator(self) -> IEnumerator: ...
    def GetFieldType(self, ordinal: int) -> typing.Type[typing.Any]: ...
    def GetFloat(self, ordinal: int) -> float: ...
    def GetGuid(self, ordinal: int) -> Guid: ...
    def GetInt16(self, ordinal: int) -> int: ...
    def GetInt32(self, ordinal: int) -> int: ...
    def GetInt64(self, ordinal: int) -> int: ...
    def GetName(self, ordinal: int) -> str: ...
    def GetOrdinal(self, name: str) -> int: ...
    def GetProviderSpecificFieldType(self, ordinal: int) -> typing.Type[typing.Any]: ...
    def GetProviderSpecificValue(self, ordinal: int) -> typing.Any: ...
    def GetProviderSpecificValues(self, values: Array_1[typing.Any]) -> int: ...
    def GetSchemaTable(self) -> DataTable: ...
    def GetString(self, ordinal: int) -> str: ...
    def GetValue(self, ordinal: int) -> typing.Any: ...
    def GetValues(self, values: Array_1[typing.Any]) -> int: ...
    def IsDBNull(self, ordinal: int) -> bool: ...
    def NextResult(self) -> bool: ...
    def Read(self) -> bool: ...

class DataView(
    MarshalByValueComponent, IBindingListView, ISupportInitializeNotification, ITypedList
):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, table: DataTable) -> None: ...
    @typing.overload
    def __init__(
        self, table: DataTable, RowFilter: str, Sort: str, RowState: DataViewRowState
    ) -> None: ...
    @property
    def AllowDelete(self) -> bool: ...
    @AllowDelete.setter
    def AllowDelete(self, value: bool) -> bool: ...
    @property
    def AllowEdit(self) -> bool: ...
    @AllowEdit.setter
    def AllowEdit(self, value: bool) -> bool: ...
    @property
    def AllowNew(self) -> bool: ...
    @AllowNew.setter
    def AllowNew(self, value: bool) -> bool: ...
    @property
    def ApplyDefaultSort(self) -> bool: ...
    @ApplyDefaultSort.setter
    def ApplyDefaultSort(self, value: bool) -> bool: ...
    @property
    def Container(self) -> IContainer: ...
    @property
    def Count(self) -> int: ...
    @property
    def DataViewManager(self) -> DataViewManager: ...
    @property
    def DesignMode(self) -> bool: ...
    @property
    def IsInitialized(self) -> bool: ...
    @property
    def Item(self) -> DataRowView: ...
    @property
    def RowFilter(self) -> str: ...
    @RowFilter.setter
    def RowFilter(self, value: str) -> str: ...
    @property
    def RowStateFilter(self) -> DataViewRowState: ...
    @RowStateFilter.setter
    def RowStateFilter(self, value: DataViewRowState) -> DataViewRowState: ...
    @property
    def Site(self) -> ISite: ...
    @Site.setter
    def Site(self, value: ISite) -> ISite: ...
    @property
    def Sort(self) -> str: ...
    @Sort.setter
    def Sort(self, value: str) -> str: ...
    @property
    def Table(self) -> DataTable: ...
    @Table.setter
    def Table(self, value: DataTable) -> DataTable: ...
    def AddNew(self) -> DataRowView: ...
    def BeginInit(self) -> None: ...
    def CopyTo(self, array: Array, index: int) -> None: ...
    def Delete(self, index: int) -> None: ...
    def EndInit(self) -> None: ...
    def Equals(self, view: DataView) -> bool: ...
    def GetEnumerator(self) -> IEnumerator: ...
    # Skipped Find due to it being static, abstract and generic.

    Find: Find_MethodGroup
    class Find_MethodGroup:
        @typing.overload
        def __call__(self, key: Array_1[typing.Any]) -> int: ...
        @typing.overload
        def __call__(self, key: typing.Any) -> int: ...

    # Skipped FindRows due to it being static, abstract and generic.

    FindRows: FindRows_MethodGroup
    class FindRows_MethodGroup:
        @typing.overload
        def __call__(self, key: Array_1[typing.Any]) -> Array_1[DataRowView]: ...
        @typing.overload
        def __call__(self, key: typing.Any) -> Array_1[DataRowView]: ...

    # Skipped ToTable due to it being static, abstract and generic.

    ToTable: ToTable_MethodGroup
    class ToTable_MethodGroup:
        @typing.overload
        def __call__(self) -> DataTable: ...
        @typing.overload
        def __call__(self, tableName: str) -> DataTable: ...
        @typing.overload
        def __call__(self, distinct: bool, columnNames: Array_1[str]) -> DataTable: ...
        @typing.overload
        def __call__(
            self, tableName: str, distinct: bool, columnNames: Array_1[str]
        ) -> DataTable: ...

class DataViewManager(MarshalByValueComponent, IBindingList, ITypedList):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, dataSet: DataSet) -> None: ...
    @property
    def Container(self) -> IContainer: ...
    @property
    def DataSet(self) -> DataSet: ...
    @DataSet.setter
    def DataSet(self, value: DataSet) -> DataSet: ...
    @property
    def DataViewSettingCollectionString(self) -> str: ...
    @DataViewSettingCollectionString.setter
    def DataViewSettingCollectionString(self, value: str) -> str: ...
    @property
    def DataViewSettings(self) -> DataViewSettingCollection: ...
    @property
    def DesignMode(self) -> bool: ...
    @property
    def Site(self) -> ISite: ...
    @Site.setter
    def Site(self, value: ISite) -> ISite: ...
    def CreateDataView(self, table: DataTable) -> DataView: ...

class DataViewRowState(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    None_: DataViewRowState  # 0
    Unchanged: DataViewRowState  # 2
    Added: DataViewRowState  # 4
    Deleted: DataViewRowState  # 8
    ModifiedCurrent: DataViewRowState  # 16
    CurrentRows: DataViewRowState  # 22
    ModifiedOriginal: DataViewRowState  # 32
    OriginalRows: DataViewRowState  # 42

class DataViewSetting:
    @property
    def ApplyDefaultSort(self) -> bool: ...
    @ApplyDefaultSort.setter
    def ApplyDefaultSort(self, value: bool) -> bool: ...
    @property
    def DataViewManager(self) -> DataViewManager: ...
    @property
    def RowFilter(self) -> str: ...
    @RowFilter.setter
    def RowFilter(self, value: str) -> str: ...
    @property
    def RowStateFilter(self) -> DataViewRowState: ...
    @RowStateFilter.setter
    def RowStateFilter(self, value: DataViewRowState) -> DataViewRowState: ...
    @property
    def Sort(self) -> str: ...
    @Sort.setter
    def Sort(self, value: str) -> str: ...
    @property
    def Table(self) -> DataTable: ...

class DataViewSettingCollection(ICollection):
    @property
    def Count(self) -> int: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def IsSynchronized(self) -> bool: ...
    @property
    def Item(self) -> DataViewSetting: ...
    @Item.setter
    def Item(self, value: DataViewSetting) -> DataViewSetting: ...
    @property
    def Item(self) -> DataViewSetting: ...
    @property
    def Item(self) -> DataViewSetting: ...
    @Item.setter
    def Item(self, value: DataViewSetting) -> DataViewSetting: ...
    @property
    def SyncRoot(self) -> typing.Any: ...
    def GetEnumerator(self) -> IEnumerator: ...
    # Skipped CopyTo due to it being static, abstract and generic.

    CopyTo: CopyTo_MethodGroup
    class CopyTo_MethodGroup:
        @typing.overload
        def __call__(self, ar: Array_1[DataViewSetting], index: int) -> None: ...
        @typing.overload
        def __call__(self, ar: Array, index: int) -> None: ...

class FillErrorEventArgs(EventArgs):
    def __init__(self, dataTable: DataTable, values: Array_1[typing.Any]) -> None: ...
    @property
    def Continue(self) -> bool: ...
    @Continue.setter
    def Continue(self, value: bool) -> bool: ...
    @property
    def DataTable(self) -> DataTable: ...
    @property
    def Errors(self) -> Exception: ...
    @Errors.setter
    def Errors(self, value: Exception) -> Exception: ...
    @property
    def Values(self) -> Array_1[typing.Any]: ...

class FillErrorEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(
        self,
        sender: typing.Any,
        e: FillErrorEventArgs,
        callback: AsyncCallback,
        object: typing.Any,
    ) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: FillErrorEventArgs) -> None: ...

class ForeignKeyConstraint(Constraint):
    @typing.overload
    def __init__(
        self, constraintName: str, parentColumn: DataColumn, childColumn: DataColumn
    ) -> None: ...
    @typing.overload
    def __init__(
        self,
        constraintName: str,
        parentColumns: Array_1[DataColumn],
        childColumns: Array_1[DataColumn],
    ) -> None: ...
    @typing.overload
    def __init__(
        self,
        constraintName: str,
        parentTableName: str,
        parentColumnNames: Array_1[str],
        childColumnNames: Array_1[str],
        acceptRejectRule: AcceptRejectRule,
        deleteRule: Rule,
        updateRule: Rule,
    ) -> None: ...
    @typing.overload
    def __init__(
        self,
        constraintName: str,
        parentTableName: str,
        parentTableNamespace: str,
        parentColumnNames: Array_1[str],
        childColumnNames: Array_1[str],
        acceptRejectRule: AcceptRejectRule,
        deleteRule: Rule,
        updateRule: Rule,
    ) -> None: ...
    @typing.overload
    def __init__(self, parentColumn: DataColumn, childColumn: DataColumn) -> None: ...
    @typing.overload
    def __init__(
        self, parentColumns: Array_1[DataColumn], childColumns: Array_1[DataColumn]
    ) -> None: ...
    @property
    def AcceptRejectRule(self) -> AcceptRejectRule: ...
    @AcceptRejectRule.setter
    def AcceptRejectRule(self, value: AcceptRejectRule) -> AcceptRejectRule: ...
    @property
    def Columns(self) -> Array_1[DataColumn]: ...
    @property
    def ConstraintName(self) -> str: ...
    @ConstraintName.setter
    def ConstraintName(self, value: str) -> str: ...
    @property
    def DeleteRule(self) -> Rule: ...
    @DeleteRule.setter
    def DeleteRule(self, value: Rule) -> Rule: ...
    @property
    def ExtendedProperties(self) -> PropertyCollection: ...
    @property
    def RelatedColumns(self) -> Array_1[DataColumn]: ...
    @property
    def RelatedTable(self) -> DataTable: ...
    @property
    def Table(self) -> DataTable: ...
    @property
    def UpdateRule(self) -> Rule: ...
    @UpdateRule.setter
    def UpdateRule(self, value: Rule) -> Rule: ...
    def Equals(self, key: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...

class IDataReader(IDataRecord, IDisposable, typing.Protocol):
    @property
    def Depth(self) -> int: ...
    @property
    def IsClosed(self) -> bool: ...
    @property
    def RecordsAffected(self) -> int: ...
    @abc.abstractmethod
    def Close(self) -> None: ...
    @abc.abstractmethod
    def GetSchemaTable(self) -> DataTable: ...
    @abc.abstractmethod
    def NextResult(self) -> bool: ...
    @abc.abstractmethod
    def Read(self) -> bool: ...

class IDataRecord(typing.Protocol):
    @property
    def FieldCount(self) -> int: ...
    @property
    def Item(self) -> typing.Any: ...
    @property
    def Item(self) -> typing.Any: ...
    @abc.abstractmethod
    def GetBoolean(self, i: int) -> bool: ...
    @abc.abstractmethod
    def GetByte(self, i: int) -> int: ...
    @abc.abstractmethod
    def GetBytes(
        self, i: int, fieldOffset: int, buffer: Array_1[int], bufferoffset: int, length: int
    ) -> int: ...
    @abc.abstractmethod
    def GetChar(self, i: int) -> str: ...
    @abc.abstractmethod
    def GetChars(
        self, i: int, fieldoffset: int, buffer: Array_1[str], bufferoffset: int, length: int
    ) -> int: ...
    @abc.abstractmethod
    def GetData(self, i: int) -> IDataReader: ...
    @abc.abstractmethod
    def GetDataTypeName(self, i: int) -> str: ...
    @abc.abstractmethod
    def GetDateTime(self, i: int) -> DateTime: ...
    @abc.abstractmethod
    def GetDecimal(self, i: int) -> Decimal: ...
    @abc.abstractmethod
    def GetDouble(self, i: int) -> float: ...
    @abc.abstractmethod
    def GetFieldType(self, i: int) -> typing.Type[typing.Any]: ...
    @abc.abstractmethod
    def GetFloat(self, i: int) -> float: ...
    @abc.abstractmethod
    def GetGuid(self, i: int) -> Guid: ...
    @abc.abstractmethod
    def GetInt16(self, i: int) -> int: ...
    @abc.abstractmethod
    def GetInt32(self, i: int) -> int: ...
    @abc.abstractmethod
    def GetInt64(self, i: int) -> int: ...
    @abc.abstractmethod
    def GetName(self, i: int) -> str: ...
    @abc.abstractmethod
    def GetOrdinal(self, name: str) -> int: ...
    @abc.abstractmethod
    def GetString(self, i: int) -> str: ...
    @abc.abstractmethod
    def GetValue(self, i: int) -> typing.Any: ...
    @abc.abstractmethod
    def GetValues(self, values: Array_1[typing.Any]) -> int: ...
    @abc.abstractmethod
    def IsDBNull(self, i: int) -> bool: ...

class InternalDataCollectionBase(ICollection):
    def __init__(self) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def IsSynchronized(self) -> bool: ...
    @property
    def SyncRoot(self) -> typing.Any: ...
    def CopyTo(self, ar: Array, index: int) -> None: ...
    def GetEnumerator(self) -> IEnumerator: ...

class LoadOption(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    OverwriteChanges: LoadOption  # 1
    PreserveChanges: LoadOption  # 2
    Upsert: LoadOption  # 3

class MappingType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Element: MappingType  # 1
    Attribute: MappingType  # 2
    SimpleContent: MappingType  # 3
    Hidden: MappingType  # 4

class MissingSchemaAction(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Add: MissingSchemaAction  # 1
    Ignore: MissingSchemaAction  # 2
    Error: MissingSchemaAction  # 3
    AddWithKey: MissingSchemaAction  # 4

class PropertyCollection(Hashtable):
    def __init__(self) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def IsFixedSize(self) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def IsSynchronized(self) -> bool: ...
    @property
    def Item(self) -> typing.Any: ...
    @Item.setter
    def Item(self, value: typing.Any) -> typing.Any: ...
    @property
    def Keys(self) -> ICollection: ...
    @property
    def SyncRoot(self) -> typing.Any: ...
    @property
    def Values(self) -> ICollection: ...
    def Clone(self) -> typing.Any: ...

class Rule(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    None_: Rule  # 0
    Cascade: Rule  # 1
    SetNull: Rule  # 2
    SetDefault: Rule  # 3

class SchemaSerializationMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    IncludeSchema: SchemaSerializationMode  # 1
    ExcludeSchema: SchemaSerializationMode  # 2

class SerializationFormat(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Xml: SerializationFormat  # 0
    Binary: SerializationFormat  # 1

class UniqueConstraint(Constraint):
    @typing.overload
    def __init__(self, column: DataColumn) -> None: ...
    @typing.overload
    def __init__(self, column: DataColumn, isPrimaryKey: bool) -> None: ...
    @typing.overload
    def __init__(self, columns: Array_1[DataColumn]) -> None: ...
    @typing.overload
    def __init__(self, columns: Array_1[DataColumn], isPrimaryKey: bool) -> None: ...
    @typing.overload
    def __init__(self, name: str, column: DataColumn) -> None: ...
    @typing.overload
    def __init__(self, name: str, column: DataColumn, isPrimaryKey: bool) -> None: ...
    @typing.overload
    def __init__(self, name: str, columnNames: Array_1[str], isPrimaryKey: bool) -> None: ...
    @typing.overload
    def __init__(self, name: str, columns: Array_1[DataColumn]) -> None: ...
    @typing.overload
    def __init__(self, name: str, columns: Array_1[DataColumn], isPrimaryKey: bool) -> None: ...
    @property
    def Columns(self) -> Array_1[DataColumn]: ...
    @property
    def ConstraintName(self) -> str: ...
    @ConstraintName.setter
    def ConstraintName(self, value: str) -> str: ...
    @property
    def ExtendedProperties(self) -> PropertyCollection: ...
    @property
    def IsPrimaryKey(self) -> bool: ...
    @property
    def Table(self) -> DataTable: ...
    def Equals(self, key2: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...

class XmlReadMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Auto: XmlReadMode  # 0
    ReadSchema: XmlReadMode  # 1
    IgnoreSchema: XmlReadMode  # 2
    InferSchema: XmlReadMode  # 3
    DiffGram: XmlReadMode  # 4
    Fragment: XmlReadMode  # 5
    InferTypedSchema: XmlReadMode  # 6

class XmlWriteMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    WriteSchema: XmlWriteMode  # 0
    IgnoreSchema: XmlWriteMode  # 1
    DiffGram: XmlWriteMode  # 2
