import typing

from System import IEquatable_1
from System.Numerics import Vector2

class Point(IEquatable_1[Point]):
    @typing.overload
    def __init__(self, dw: int) -> None: ...
    @typing.overload
    def __init__(self, sz: Size) -> None: ...
    @typing.overload
    def __init__(self, x: int, y: int) -> None: ...
    Empty: Point
    @property
    def IsEmpty(self) -> bool: ...
    @property
    def X(self) -> int: ...
    @X.setter
    def X(self, value: int) -> int: ...
    @property
    def Y(self) -> int: ...
    @Y.setter
    def Y(self, value: int) -> int: ...
    @staticmethod
    def Add(pt: Point, sz: Size) -> Point: ...
    @staticmethod
    def Ceiling(value: PointF) -> Point: ...
    def GetHashCode(self) -> int: ...
    def __add__(self, pt: Point, sz: Size) -> Point: ...
    def __eq__(self, left: Point, right: Point) -> bool: ...
    # Operator not supported op_Explicit(p: Point)
    # Operator not supported op_Implicit(p: Point)
    def __ne__(self, left: Point, right: Point) -> bool: ...
    def __sub__(self, pt: Point, sz: Size) -> Point: ...
    @staticmethod
    def Round(value: PointF) -> Point: ...
    @staticmethod
    def Subtract(pt: Point, sz: Size) -> Point: ...
    def ToString(self) -> str: ...
    @staticmethod
    def Truncate(value: PointF) -> Point: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals: Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Point) -> bool: ...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool: ...

    # Skipped Offset due to it being static, abstract and generic.

    Offset: Offset_MethodGroup
    class Offset_MethodGroup:
        @typing.overload
        def __call__(self, p: Point) -> None: ...
        @typing.overload
        def __call__(self, dx: int, dy: int) -> None: ...

class PointF(IEquatable_1[PointF]):
    @typing.overload
    def __init__(self, vector: Vector2) -> None: ...
    @typing.overload
    def __init__(self, x: float, y: float) -> None: ...
    Empty: PointF
    @property
    def IsEmpty(self) -> bool: ...
    @property
    def X(self) -> float: ...
    @X.setter
    def X(self, value: float) -> float: ...
    @property
    def Y(self) -> float: ...
    @Y.setter
    def Y(self, value: float) -> float: ...
    def GetHashCode(self) -> int: ...
    @typing.overload
    def __add__(self, pt: PointF, sz: Size) -> PointF: ...
    @typing.overload
    def __add__(self, pt: PointF, sz: SizeF) -> PointF: ...
    def __eq__(self, left: PointF, right: PointF) -> bool: ...
    # Operator not supported op_Explicit(point: PointF)
    # Operator not supported op_Explicit(vector: Vector2)
    def __ne__(self, left: PointF, right: PointF) -> bool: ...
    @typing.overload
    def __sub__(self, pt: PointF, sz: Size) -> PointF: ...
    @typing.overload
    def __sub__(self, pt: PointF, sz: SizeF) -> PointF: ...
    def ToString(self) -> str: ...
    def ToVector2(self) -> Vector2: ...
    # Skipped Add due to it being static, abstract and generic.

    Add: Add_MethodGroup
    class Add_MethodGroup:
        @typing.overload
        def __call__(self, pt: PointF, sz: Size) -> PointF: ...
        @typing.overload
        def __call__(self, pt: PointF, sz: SizeF) -> PointF: ...

    # Skipped Equals due to it being static, abstract and generic.

    Equals: Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: PointF) -> bool: ...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool: ...

    # Skipped Subtract due to it being static, abstract and generic.

    Subtract: Subtract_MethodGroup
    class Subtract_MethodGroup:
        @typing.overload
        def __call__(self, pt: PointF, sz: Size) -> PointF: ...
        @typing.overload
        def __call__(self, pt: PointF, sz: SizeF) -> PointF: ...

class Size(IEquatable_1[Size]):
    @typing.overload
    def __init__(self, pt: Point) -> None: ...
    @typing.overload
    def __init__(self, width: int, height: int) -> None: ...
    Empty: Size
    @property
    def Height(self) -> int: ...
    @Height.setter
    def Height(self, value: int) -> int: ...
    @property
    def IsEmpty(self) -> bool: ...
    @property
    def Width(self) -> int: ...
    @Width.setter
    def Width(self, value: int) -> int: ...
    @staticmethod
    def Add(sz1: Size, sz2: Size) -> Size: ...
    @staticmethod
    def Ceiling(value: SizeF) -> Size: ...
    def GetHashCode(self) -> int: ...
    def __add__(self, sz1: Size, sz2: Size) -> Size: ...
    @typing.overload
    def __truediv__(self, left: Size, right: float) -> SizeF: ...
    @typing.overload
    def __truediv__(self, left: Size, right: int) -> Size: ...
    def __eq__(self, sz1: Size, sz2: Size) -> bool: ...
    # Operator not supported op_Explicit(size: Size)
    # Operator not supported op_Implicit(p: Size)
    def __ne__(self, sz1: Size, sz2: Size) -> bool: ...
    @typing.overload
    def __mul__(self, left: float, right: Size) -> SizeF: ...
    @typing.overload
    def __mul__(self, left: int, right: Size) -> Size: ...
    @typing.overload
    def __mul__(self, left: Size, right: float) -> SizeF: ...
    @typing.overload
    def __mul__(self, left: Size, right: int) -> Size: ...
    def __sub__(self, sz1: Size, sz2: Size) -> Size: ...
    @staticmethod
    def Round(value: SizeF) -> Size: ...
    @staticmethod
    def Subtract(sz1: Size, sz2: Size) -> Size: ...
    def ToString(self) -> str: ...
    @staticmethod
    def Truncate(value: SizeF) -> Size: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals: Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Size) -> bool: ...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool: ...

class SizeF(IEquatable_1[SizeF]):
    @typing.overload
    def __init__(self, pt: PointF) -> None: ...
    @typing.overload
    def __init__(self, size: SizeF) -> None: ...
    @typing.overload
    def __init__(self, vector: Vector2) -> None: ...
    @typing.overload
    def __init__(self, width: float, height: float) -> None: ...
    Empty: SizeF
    @property
    def Height(self) -> float: ...
    @Height.setter
    def Height(self, value: float) -> float: ...
    @property
    def IsEmpty(self) -> bool: ...
    @property
    def Width(self) -> float: ...
    @Width.setter
    def Width(self, value: float) -> float: ...
    @staticmethod
    def Add(sz1: SizeF, sz2: SizeF) -> SizeF: ...
    def GetHashCode(self) -> int: ...
    def __add__(self, sz1: SizeF, sz2: SizeF) -> SizeF: ...
    def __truediv__(self, left: SizeF, right: float) -> SizeF: ...
    def __eq__(self, sz1: SizeF, sz2: SizeF) -> bool: ...
    # Operator not supported op_Explicit(size: SizeF)
    # Operator not supported op_Explicit(size: SizeF)
    # Operator not supported op_Explicit(vector: Vector2)
    def __ne__(self, sz1: SizeF, sz2: SizeF) -> bool: ...
    @typing.overload
    def __mul__(self, left: float, right: SizeF) -> SizeF: ...
    @typing.overload
    def __mul__(self, left: SizeF, right: float) -> SizeF: ...
    def __sub__(self, sz1: SizeF, sz2: SizeF) -> SizeF: ...
    @staticmethod
    def Subtract(sz1: SizeF, sz2: SizeF) -> SizeF: ...
    def ToPointF(self) -> PointF: ...
    def ToSize(self) -> Size: ...
    def ToString(self) -> str: ...
    def ToVector2(self) -> Vector2: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals: Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: SizeF) -> bool: ...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool: ...
