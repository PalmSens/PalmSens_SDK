import abc
import typing

from MathNet.Numerics.LinearAlgebra import Matrix_1, Vector_1
from PalmSens.Fitting.Models.Circuits import ElementGroup
from PalmSens.Fitting.Models.Circuits.Elements import ElementTypes
from PalmSens.Plottables import EISData
from System import Array_1, Progress_1
from System.Collections.Generic import List_1
from System.Threading.Tasks import Task_1

class Algorithm(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    LevenbergMarquardt: Algorithm  # 0
    NelderMead: Algorithm  # 1

class BVModel(IModelBase):
    def __init__(self) -> None: ...
    Begin: int
    End: int
    @property
    def Name(self) -> str: ...
    @property
    def NParameters(self) -> int: ...
    def GetResidualValues(
        self, parameters: Array_1[float], x: Array_1[float], y: Array_1[float]
    ) -> Array_1[float]: ...
    def GetValues(self, parameters: Array_1[float], x: Array_1[float]) -> Array_1[float]: ...
    # Skipped EvaluatePointError due to it being static, abstract and generic.

    EvaluatePointError: EvaluatePointError_MethodGroup
    class EvaluatePointError_MethodGroup:
        @typing.overload
        def __call__(self, parameters: Array_1[float]) -> float: ...
        @typing.overload
        def __call__(
            self, parameters: Array_1[float], fitOptionsCircuit: FitOptionsCircuit
        ) -> float: ...

class BVModelICorr(IModelBase):
    def __init__(self, eCorr: float, bA: float, bC: float) -> None: ...
    Begin: int
    End: int
    @property
    def Name(self) -> str: ...
    @property
    def NParameters(self) -> int: ...
    def GetResidualValues(
        self, parameters: Array_1[float], x: Array_1[float], y: Array_1[float]
    ) -> Array_1[float]: ...
    def GetValues(self, parameters: Array_1[float], x: Array_1[float]) -> Array_1[float]: ...
    # Skipped EvaluatePointError due to it being static, abstract and generic.

    EvaluatePointError: EvaluatePointError_MethodGroup
    class EvaluatePointError_MethodGroup:
        @typing.overload
        def __call__(self, parameters: Array_1[float]) -> float: ...
        @typing.overload
        def __call__(
            self, parameters: Array_1[float], fitOptionsCircuit: FitOptionsCircuit
        ) -> float: ...

class BVModelICorrSimplex(IModelBase):
    def __init__(
        self, eCorr: float, ba: float, bc: float, x: Array_1[float], y: Array_1[float]
    ) -> None: ...
    Begin: int
    End: int
    @property
    def Name(self) -> str: ...
    @property
    def NParameters(self) -> int: ...
    def GetResidualValues(
        self, parameters: Array_1[float], x: Array_1[float], y: Array_1[float]
    ) -> Array_1[float]: ...
    def GetValues(self, parameters: Array_1[float], x: Array_1[float]) -> Array_1[float]: ...
    # Skipped EvaluatePointError due to it being static, abstract and generic.

    EvaluatePointError: EvaluatePointError_MethodGroup
    class EvaluatePointError_MethodGroup:
        @typing.overload
        def __call__(self, parameters: Array_1[float]) -> float: ...
        @typing.overload
        def __call__(
            self, parameters: Array_1[float], fitOptionsCircuit: FitOptionsCircuit
        ) -> float: ...

class BVModelSimplex(IModelBase):
    def __init__(self, x: Array_1[float], y: Array_1[float], eCorr: float) -> None: ...
    Begin: int
    End: int
    @property
    def Name(self) -> str: ...
    @property
    def NParameters(self) -> int: ...
    def GetResidualValues(
        self, parameters: Array_1[float], x: Array_1[float], y: Array_1[float]
    ) -> Array_1[float]: ...
    def GetValues(self, parameters: Array_1[float], x: Array_1[float]) -> Array_1[float]: ...
    # Skipped EvaluatePointError due to it being static, abstract and generic.

    EvaluatePointError: EvaluatePointError_MethodGroup
    class EvaluatePointError_MethodGroup:
        @typing.overload
        def __call__(self, parameters: Array_1[float]) -> float: ...
        @typing.overload
        def __call__(
            self, parameters: Array_1[float], fitOptionsCircuit: FitOptionsCircuit
        ) -> float: ...

class BVModelSlopeAn(IModelBase):
    def __init__(self, eCorr: float, bC: float) -> None: ...
    Begin: int
    End: int
    @property
    def Name(self) -> str: ...
    @property
    def NParameters(self) -> int: ...
    def GetResidualValues(
        self, parameters: Array_1[float], x: Array_1[float], y: Array_1[float]
    ) -> Array_1[float]: ...
    def GetValues(self, parameters: Array_1[float], x: Array_1[float]) -> Array_1[float]: ...
    # Skipped EvaluatePointError due to it being static, abstract and generic.

    EvaluatePointError: EvaluatePointError_MethodGroup
    class EvaluatePointError_MethodGroup:
        @typing.overload
        def __call__(self, parameters: Array_1[float]) -> float: ...
        @typing.overload
        def __call__(
            self, parameters: Array_1[float], fitOptionsCircuit: FitOptionsCircuit
        ) -> float: ...

class BVModelSlopeCath(IModelBase):
    def __init__(self, eCorr: float, bA: float) -> None: ...
    Begin: int
    End: int
    @property
    def Name(self) -> str: ...
    @property
    def NParameters(self) -> int: ...
    def GetResidualValues(
        self, parameters: Array_1[float], x: Array_1[float], y: Array_1[float]
    ) -> Array_1[float]: ...
    def GetValues(self, parameters: Array_1[float], x: Array_1[float]) -> Array_1[float]: ...
    # Skipped EvaluatePointError due to it being static, abstract and generic.

    EvaluatePointError: EvaluatePointError_MethodGroup
    class EvaluatePointError_MethodGroup:
        @typing.overload
        def __call__(self, parameters: Array_1[float]) -> float: ...
        @typing.overload
        def __call__(
            self, parameters: Array_1[float], fitOptionsCircuit: FitOptionsCircuit
        ) -> float: ...

class BVModelSlopesSimplex(IModelBase):
    def __init__(
        self, eCorr: float, iCorr: float, x: Array_1[float], y: Array_1[float]
    ) -> None: ...
    Begin: int
    End: int
    @property
    def Name(self) -> str: ...
    @property
    def NParameters(self) -> int: ...
    def GetResidualValues(
        self, parameters: Array_1[float], x: Array_1[float], y: Array_1[float]
    ) -> Array_1[float]: ...
    def GetValues(self, parameters: Array_1[float], x: Array_1[float]) -> Array_1[float]: ...
    # Skipped EvaluatePointError due to it being static, abstract and generic.

    EvaluatePointError: EvaluatePointError_MethodGroup
    class EvaluatePointError_MethodGroup:
        @typing.overload
        def __call__(self, parameters: Array_1[float]) -> float: ...
        @typing.overload
        def __call__(
            self, parameters: Array_1[float], fitOptionsCircuit: FitOptionsCircuit
        ) -> float: ...

class EnumFitProgress(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Started: EnumFitProgress  # 0
    FitIterated: EnumFitProgress  # 1
    Cancelled: EnumFitProgress  # 2
    Finished: EnumFitProgress  # 3

class ExitCodes(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    MinimumDeltaErrorTerm: ExitCodes  # 1
    MinimumDeltaParameters: ExitCodes  # 2
    MaxIterations: ExitCodes  # 3
    HessianNonPositive: ExitCodes  # 4

class ExitCondition(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    None_: ExitCondition  # 0
    RelativeGradient: ExitCondition  # 1
    LackOfProgress: ExitCondition  # 2
    AbsoluteGradient: ExitCondition  # 3
    WeakWolfeCriteria: ExitCondition  # 4
    BoundTolerance: ExitCondition  # 5
    StrongWolfeCriteria: ExitCondition  # 6
    Converged: ExitCondition  # 7

class FitAlgorithm(abc.ABC):
    @typing.overload
    def __init__(self, fitOptions: FitOptionsCircuit) -> None: ...
    @typing.overload
    def __init__(self, fitOptions: FitOptions) -> None: ...
    @property
    def FitResult(self) -> FitResult: ...
    @FitResult.setter
    def FitResult(self, value: FitResult) -> FitResult: ...
    @property
    def Iterations(self) -> List_1[Array_1[float]]: ...
    @abc.abstractmethod
    def ApplyFit(self) -> FitResult: ...
    def ApplyFitCircuitAsync(self, fitProgress: FitProgress = ...) -> Task_1[FitResult]: ...
    @staticmethod
    def FromAlgorithm(fitOptions: FitOptionsCircuit) -> FitAlgorithm: ...
    # Skipped ApplyFitCircuit due to it being static, abstract and generic.

    ApplyFitCircuit: ApplyFitCircuit_MethodGroup
    class ApplyFitCircuit_MethodGroup:
        @typing.overload
        def __call__(self) -> None: ...
        @typing.overload
        def __call__(self, fitProgress: FitProgress) -> None: ...

class FitOptions:
    def __init__(
        self,
        xData: Array_1[float],
        yData: Array_1[float],
        model: IModelBase,
        initialParameters: Array_1[float],
    ) -> None: ...
    @property
    def ConvergenceTolerance(self) -> float: ...
    @ConvergenceTolerance.setter
    def ConvergenceTolerance(self, value: float) -> float: ...
    @property
    def EnableMinimunDeltaErrorTerm(self) -> bool: ...
    @EnableMinimunDeltaErrorTerm.setter
    def EnableMinimunDeltaErrorTerm(self, value: bool) -> bool: ...
    @property
    def EnableMinimunDeltaParameters(self) -> bool: ...
    @EnableMinimunDeltaParameters.setter
    def EnableMinimunDeltaParameters(self, value: bool) -> bool: ...
    @property
    def InitialParameters(self) -> Array_1[float]: ...
    @InitialParameters.setter
    def InitialParameters(self, value: Array_1[float]) -> Array_1[float]: ...
    @property
    def Lambda(self) -> float: ...
    @Lambda.setter
    def Lambda(self, value: float) -> float: ...
    @property
    def LambdaFactor(self) -> float: ...
    @LambdaFactor.setter
    def LambdaFactor(self, value: float) -> float: ...
    @property
    def MaxIterations(self) -> int: ...
    @MaxIterations.setter
    def MaxIterations(self, value: int) -> int: ...
    @property
    def MinimumDeltaErrorTerm(self) -> float: ...
    @MinimumDeltaErrorTerm.setter
    def MinimumDeltaErrorTerm(self, value: float) -> float: ...
    @property
    def MinimumDeltaParameters(self) -> float: ...
    @MinimumDeltaParameters.setter
    def MinimumDeltaParameters(self, value: float) -> float: ...
    @property
    def Model(self) -> IModelBase: ...
    @Model.setter
    def Model(self, value: IModelBase) -> IModelBase: ...
    @property
    def SelectedAlgorithm(self) -> Algorithm: ...
    @SelectedAlgorithm.setter
    def SelectedAlgorithm(self, value: Algorithm) -> Algorithm: ...
    @property
    def XData(self) -> Array_1[float]: ...
    @property
    def YData(self) -> Array_1[float]: ...

class FitOptionsCircuit(FitOptions):
    def __init__(self) -> None: ...

    class FitTypes(typing.SupportsInt):
        @typing.overload
        def __init__(self, value: int) -> None: ...
        @typing.overload
        def __init__(self, value: int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...

        # Values:
        Real: FitOptionsCircuit.FitTypes  # 0
        Imaginary: FitOptionsCircuit.FitTypes  # 1
        Complex: FitOptionsCircuit.FitTypes  # 2

    class Weighting(typing.SupportsInt):
        @typing.overload
        def __init__(self, value: int) -> None: ...
        @typing.overload
        def __init__(self, value: int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...

        # Values:
        Unit: FitOptionsCircuit.Weighting  # 0
        Modulus: FitOptionsCircuit.Weighting  # 1
        Proportional: FitOptionsCircuit.Weighting  # 2

    @property
    def AllDataPoints(self) -> bool: ...
    @AllDataPoints.setter
    def AllDataPoints(self, value: bool) -> bool: ...
    @property
    def ConvergenceTolerance(self) -> float: ...
    @ConvergenceTolerance.setter
    def ConvergenceTolerance(self, value: float) -> float: ...
    @property
    def EnableMinimunDeltaErrorTerm(self) -> bool: ...
    @EnableMinimunDeltaErrorTerm.setter
    def EnableMinimunDeltaErrorTerm(self, value: bool) -> bool: ...
    @property
    def EnableMinimunDeltaParameters(self) -> bool: ...
    @EnableMinimunDeltaParameters.setter
    def EnableMinimunDeltaParameters(self, value: bool) -> bool: ...
    @property
    def FitType(self) -> FitTypes: ...
    @FitType.setter
    def FitType(self, value: FitTypes) -> FitTypes: ...
    @property
    def InitialParameters(self) -> Array_1[float]: ...
    @InitialParameters.setter
    def InitialParameters(self, value: Array_1[float]) -> Array_1[float]: ...
    @property
    def Lambda(self) -> float: ...
    @Lambda.setter
    def Lambda(self, value: float) -> float: ...
    @property
    def LambdaFactor(self) -> float: ...
    @LambdaFactor.setter
    def LambdaFactor(self, value: float) -> float: ...
    @property
    def MaxIterations(self) -> int: ...
    @MaxIterations.setter
    def MaxIterations(self, value: int) -> int: ...
    @property
    def MinimumDeltaErrorTerm(self) -> float: ...
    @MinimumDeltaErrorTerm.setter
    def MinimumDeltaErrorTerm(self, value: float) -> float: ...
    @property
    def MinimumDeltaParameters(self) -> float: ...
    @MinimumDeltaParameters.setter
    def MinimumDeltaParameters(self, value: float) -> float: ...
    @property
    def Model(self) -> IModelBase: ...
    @Model.setter
    def Model(self, value: IModelBase) -> IModelBase: ...
    @property
    def RawData(self) -> EISData: ...
    @RawData.setter
    def RawData(self, value: EISData) -> EISData: ...
    @property
    def SelectedAlgorithm(self) -> Algorithm: ...
    @SelectedAlgorithm.setter
    def SelectedAlgorithm(self, value: Algorithm) -> Algorithm: ...
    @property
    def SelectedDataPoints(self) -> Array_1[bool]: ...
    @SelectedDataPoints.setter
    def SelectedDataPoints(self, value: Array_1[bool]) -> Array_1[bool]: ...
    @property
    def Weight(self) -> Weighting: ...
    @Weight.setter
    def Weight(self, value: Weighting) -> Weighting: ...
    @property
    def XData(self) -> Array_1[float]: ...
    @property
    def YData(self) -> Array_1[float]: ...

class FitProgress(Progress_1[FitProgressUpdate]):
    def __init__(self) -> None: ...
    FitAlgorithm: FitAlgorithm
    FitOptions: FitOptionsCircuit
    def Cancel(self) -> None: ...

class FitProgressUpdate:
    NIterations: int
    Progress: EnumFitProgress
    Result: FitResult

class FitResult:
    @typing.overload
    def __init__(
        self,
        iterations: List_1[Array_1[float]],
        alphaCNLS: Matrix_1[float],
        residualSS: float,
        nSamples: int,
        exitCode: int,
    ) -> None: ...
    @typing.overload
    def __init__(
        self,
        iterations: List_1[Array_1[float]],
        residualSS: float,
        nSamples: int,
        exitCode: int,
    ) -> None: ...
    @typing.overload
    def __init__(
        self,
        parameters: Parameters,
        iterations: List_1[Array_1[float]],
        alphaCNLS: Matrix_1[float],
        residualSS: float,
        nSamples: int,
        exitCode: int,
    ) -> None: ...
    @property
    def ChiSq(self) -> float: ...
    @property
    def ExitCode(self) -> ExitCodes: ...
    @property
    def FinalParameters(self) -> Array_1[float]: ...
    @property
    def Iterations(self) -> List_1[Array_1[float]]: ...
    @property
    def NIterations(self) -> int: ...
    @property
    def ParameterSDs(self) -> Array_1[float]: ...

class IModelBase(typing.Protocol):
    @property
    def Name(self) -> str: ...
    @property
    def NParameters(self) -> int: ...
    @abc.abstractmethod
    def GetResidualValues(
        self, parameters: Array_1[float], x: Array_1[float], y: Array_1[float]
    ) -> Array_1[float]: ...
    @abc.abstractmethod
    def GetValues(self, parameters: Array_1[float], x: Array_1[float]) -> Array_1[float]: ...
    # Skipped EvaluatePointError due to it being static, abstract and generic.

    EvaluatePointError: EvaluatePointError_MethodGroup
    class EvaluatePointError_MethodGroup:
        @typing.overload
        def __call__(self, parameters: Array_1[float]) -> float: ...
        @typing.overload
        def __call__(
            self, parameters: Array_1[float], fitOptionsCircuit: FitOptionsCircuit
        ) -> float: ...

class LevenbergMarquardt(FitAlgorithm):
    def __init__(self, fitOptions: FitOptions) -> None: ...
    @property
    def FitResult(self) -> FitResult: ...
    @FitResult.setter
    def FitResult(self, value: FitResult) -> FitResult: ...
    @property
    def Iterations(self) -> List_1[Array_1[float]]: ...
    def ApplyFit(self) -> FitResult: ...
    def ApplyFitCircuit(self) -> None: ...

class NelderMead(FitAlgorithm):
    @typing.overload
    def __init__(self, fitOptions: FitOptions) -> None: ...
    @typing.overload
    def __init__(self, fitOptions: FitOptionsCircuit) -> None: ...
    @property
    def FitResult(self) -> FitResult: ...
    @FitResult.setter
    def FitResult(self, value: FitResult) -> FitResult: ...
    @property
    def Iterations(self) -> List_1[Array_1[float]]: ...
    def ApplyFit(self) -> FitResult: ...
    def ApplyFitCircuit(self) -> None: ...
    # Skipped FindMinimum due to it being static, abstract and generic.

    FindMinimum: FindMinimum_MethodGroup
    class FindMinimum_MethodGroup:
        @typing.overload
        def __call__(self, initialGuess: Vector_1[float]) -> FitResult: ...
        @typing.overload
        def __call__(
            self, initialGuess: Vector_1[float], initalPertubation: Vector_1[float]
        ) -> FitResult: ...

    # Skipped Minimum due to it being static, abstract and generic.

    Minimum: Minimum_MethodGroup
    class Minimum_MethodGroup:
        @typing.overload
        def __call__(
            self,
            initialGuess: Vector_1[float],
            convergenceTolerance: float = ...,
            maximumIterations: int = ...,
        ) -> FitResult: ...
        @typing.overload
        def __call__(
            self,
            initialGuess: Vector_1[float],
            initalPertubation: Vector_1[float],
            convergenceTolerance: float = ...,
            maximumIterations: int = ...,
        ) -> FitResult: ...

class Parameter:
    @typing.overload
    def __init__(self, _grp: ElementGroup) -> None: ...
    @typing.overload
    def __init__(self, _grp: ElementGroup, _npar: int) -> None: ...
    Fixed: bool
    @property
    def MaxValue(self) -> float: ...
    @MaxValue.setter
    def MaxValue(self, value: float) -> float: ...
    @property
    def MinValue(self) -> float: ...
    @MinValue.setter
    def MinValue(self, value: float) -> float: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...
    @property
    def ParameterNumber(self) -> int: ...
    @ParameterNumber.setter
    def ParameterNumber(self, value: int) -> int: ...
    @property
    def Symbol(self) -> str: ...
    @Symbol.setter
    def Symbol(self, value: str) -> str: ...
    @property
    def Type(self) -> ElementTypes: ...
    @Type.setter
    def Type(self, value: ElementTypes) -> ElementTypes: ...
    @property
    def Value(self) -> float: ...
    @Value.setter
    def Value(self, value: float) -> float: ...

class Parameters(List_1[Parameter]):
    def __init__(self) -> None: ...
    FixedParameterCount: int
    @property
    def Capacity(self) -> int: ...
    @Capacity.setter
    def Capacity(self, value: int) -> int: ...
    @property
    def Count(self) -> int: ...
    @property
    def CurrentFitValues(self) -> Array_1[float]: ...
    @CurrentFitValues.setter
    def CurrentFitValues(self, value: Array_1[float]) -> Array_1[float]: ...
    @property
    def CurrentValues(self) -> Array_1[float]: ...
    @property
    def Item(self) -> Parameter: ...
    @Item.setter
    def Item(self, value: Parameter) -> Parameter: ...
    @property
    def NextFitValues(self) -> Array_1[float]: ...
    @NextFitValues.setter
    def NextFitValues(self, value: Array_1[float]) -> Array_1[float]: ...
    @property
    def NextValues(self) -> Array_1[float]: ...
    def AddStep(self, step: Array_1[float]) -> None: ...
    def InitCurrentFitValues(self) -> None: ...
    def SetNewFitValuesAsCurrent(self) -> None: ...
