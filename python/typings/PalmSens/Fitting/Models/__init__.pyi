import typing

from MathNet.Numerics.LinearAlgebra import Vector_1
from PalmSens.Fitting import FitOptionsCircuit, IModelBase, Parameters
from PalmSens.Fitting.Models.Circuits import ISubGroup
from PalmSens.Plottables import Curve, EISData
from System import Array_1
from System.Collections.Generic import IList_1, List_1
from System.Numerics import Complex

class CircuitModel(IModelBase):
    def __init__(self) -> None: ...
    @property
    def ChiSq(self) -> float: ...
    @ChiSq.setter
    def ChiSq(self, value: float) -> float: ...
    @property
    def EISData(self) -> EISData: ...
    @property
    def InitialParameters(self) -> Parameters: ...
    @InitialParameters.setter
    def InitialParameters(self, value: Parameters) -> Parameters: ...
    @property
    def Name(self) -> str: ...
    @property
    def NIterations(self) -> int: ...
    @NIterations.setter
    def NIterations(self, value: int) -> int: ...
    @property
    def NParameters(self) -> int: ...
    @property
    def ParameterSDs(self) -> Array_1[float]: ...
    @ParameterSDs.setter
    def ParameterSDs(self, value: Array_1[float]) -> Array_1[float]: ...
    @property
    def PrefixMultiplier(self) -> Array_1[float]: ...
    def CloneModelParameters(self, cloneFrom: CircuitModel) -> None: ...
    def GetCapacitance(self) -> Array_1[Curve]: ...
    def GetCircuitParameterValues(
        self, circuit: List_1[ISubGroup], excludePreviews: bool = ...
    ) -> Array_1[float]: ...
    def GetCurvePhaseOverFrequency(self, logF: bool = ...) -> Array_1[Curve]: ...
    def GetCurveZabsOverFrequency(self, logF: bool = ...) -> Array_1[Curve]: ...
    def GetEISDataResult(self) -> EISData: ...
    def GetErrorPhase(self, logF: bool = ...) -> Array_1[Curve]: ...
    def GetErrorZabs(self, logF: bool = ...) -> Array_1[Curve]: ...
    def GetErrorZreal(self, logF: bool = ...) -> Array_1[Curve]: ...
    def GetNyquist(self) -> Array_1[Curve]: ...
    def GetResidualValue(
        self, parameters: Array_1[float], omega: float, zRaw: Complex
    ) -> Complex: ...
    def GetResidualValues(
        self, parameters: Array_1[float], x: Array_1[float], y: Array_1[float]
    ) -> Array_1[float]: ...
    def GetValue(self, parameters: Array_1[float], omega: float) -> Complex: ...
    def GetValues(
        self, parameters: Array_1[float], omega: Array_1[float]
    ) -> Array_1[Complex]: ...
    def InitialParameterValues(self) -> Array_1[float]: ...
    def InitOmega(self, omega: Vector_1[float]) -> None: ...
    def SetCircuitParameterValues(
        self, circuit: List_1[ISubGroup], values: Array_1[float]
    ) -> List_1[ISubGroup]: ...
    def SetEISdata(self, data: EISData) -> None: ...
    def SetFitResults(
        self, chiSquare: float, parSDs: Array_1[float], iterations: int, exitCode: int
    ) -> None: ...
    def SetFixedParameters(self, fixedParameters: IList_1[bool]) -> None: ...
    def SetInitialParameters(self, newParameters: Array_1[float]) -> None: ...
    # Skipped EvaluatePointError due to it being static, abstract and generic.

    EvaluatePointError: EvaluatePointError_MethodGroup
    class EvaluatePointError_MethodGroup:
        @typing.overload
        def __call__(self, parameters: Array_1[float]) -> float: ...
        @typing.overload
        def __call__(
            self, parameters: Array_1[float], fitOptionsCircuit: FitOptionsCircuit
        ) -> float: ...

    # Skipped SetCircuit due to it being static, abstract and generic.

    SetCircuit: SetCircuit_MethodGroup
    class SetCircuit_MethodGroup:
        @typing.overload
        def __call__(self, _circuit: List_1[ISubGroup]) -> None: ...
        @typing.overload
        def __call__(self, cdc: str) -> None: ...
