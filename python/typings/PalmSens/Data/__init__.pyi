import abc
import typing

from Newtonsoft.Json import JsonReader, JsonWriter
from PalmSens import CurrentRange, MeasType, Measurement, Method, PotentialRange
from PalmSens.Analysis import LevelDetectProgress, PeakDetectProgress
from PalmSens.Comm import ReadingStatus, TimingStatus
from PalmSens.DataFiles import JsonBag, SessionFile
from PalmSens.Plottables import Curve, EISData
from PalmSens.Units import Unit
from System import (
    Array_1,
    AsyncCallback,
    DateTime,
    EventArgs,
    Exception,
    Func_2,
    Func_3,
    IAsyncResult,
    IDisposable,
    IProgress_1,
    MulticastDelegate,
    Version,
)
from System.Collections import IDictionary, IEnumerator
from System.Collections.Generic import (
    Dictionary_2,
    IEnumerable_1,
    IEnumerator_1,
    IList_1,
    List_1,
)
from System.IO import Stream
from System.Reflection import MethodBase, MethodInfo
from System.Threading import CancellationToken
from System.Threading.Tasks import Task, Task_1

class ArrayDataAddedEventArgs(EventArgs):
    def __init__(self, iStart: int, count: int) -> None: ...
    Count: int
    StartIndex: int

class CurrentReading(IDataValue):
    @typing.overload
    def __init__(self, bag: JsonBag, coreVersion: Version) -> None: ...
    @typing.overload
    def __init__(self, status: ReadingStatus, timingStatus: TimingStatus = ...) -> None: ...
    @typing.overload
    def __init__(
        self,
        value: float,
        range: CurrentRange,
        status: ReadingStatus,
        timingStatus: TimingStatus = ...,
    ) -> None: ...
    CurrentRange: CurrentRange
    ReadingStatus: ReadingStatus
    TimingStatus: TimingStatus
    @property
    def Text(self) -> str: ...
    @Text.setter
    def Text(self, value: str) -> str: ...
    @property
    def Value(self) -> float: ...
    @Value.setter
    def Value(self, value: float) -> float: ...
    @property
    def ValueInRange(self) -> float: ...
    def Copy(self) -> IDataValue: ...
    def GetFormattedValue(self) -> str: ...
    def GetFormattedValueInCR(self) -> str: ...
    def ToJsonBag(self) -> JsonBag: ...
    def ToJsonWriter(self, jw: JsonWriter, cancellationToken: CancellationToken) -> Task: ...

class CurveHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(
        self,
        sender: typing.Any,
        e: CurvesChangedEventArgs,
        callback: AsyncCallback,
        object: typing.Any,
    ) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: CurvesChangedEventArgs) -> None: ...

class CurvesChangedEventArgs(EventArgs):
    def __init__(self, curves: Array_1[Curve]) -> None: ...
    ChangedCurves: Array_1[Curve]

class DataArray(IList_1[IDataValue], IDisposable):
    @typing.overload
    def __init__(self, bag: JsonBag, coreVersion: Version) -> None: ...
    @typing.overload
    def __init__(
        self, description: str, unit: Unit, dataValueTypeStr: str, type: DataArrayType
    ) -> None: ...
    @typing.overload
    def __init__(
        self, description: str, unit: Unit, dataValueTypeStr: str, type: int
    ) -> None: ...
    @typing.overload
    def __init__(self, description: str, unit: Unit, type: DataArrayType) -> None: ...
    @typing.overload
    def __init__(self, description: str, unit: Unit, type: int) -> None: ...

    class JsonValueParser:
        def __init__(self) -> None: ...
        ParseValue: Func_2[JsonReader, Task_1[IDataValue]]
        @staticmethod
        def Factory(
            parseValueFunc: Func_2[JsonReader, Task_1[IDataValue]] = ...,
        ) -> DataArray.JsonValueParser: ...

    class NewDataAddedEventHandler(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(
            self,
            sender: typing.Any,
            e: ArrayDataAddedEventArgs,
            callback: AsyncCallback,
            object: typing.Any,
        ) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, sender: typing.Any, e: ArrayDataAddedEventArgs) -> None: ...

    AUX_DESCRIPTION: str
    CURRENT_DESCRIPTION: str
    IsFinished: bool
    LOG_CURRENT_DESCRIPTION: str
    OCPValue: float
    POTENTIAL_DESCRIPTION: str
    TEMPERATURE_DESCRIPTION: str
    TIME_DESCRIPTION: str
    @property
    def ArrayType(self) -> int: ...
    @property
    def Count(self) -> int: ...
    @property
    def DataValueTypeStr(self) -> str: ...
    @property
    def Description(self) -> str: ...
    @Description.setter
    def Description(self, value: str) -> str: ...
    @property
    def Hidden(self) -> bool: ...
    @Hidden.setter
    def Hidden(self, value: bool) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def Item(self) -> IDataValue: ...
    @Item.setter
    def Item(self, value: IDataValue) -> IDataValue: ...
    @property
    def MaxValue(self) -> float: ...
    @property
    def MinValue(self) -> float: ...
    @property
    def Unit(self) -> Unit: ...
    def Add(self, item: IDataValue) -> None: ...
    def Clear(self) -> None: ...
    def Clone(self, includingData: bool = ...) -> DataArray: ...
    def Contains(self, item: IDataValue) -> bool: ...
    @staticmethod
    def DataArrayTypeFromJsonBag(
        typeStr: str, arrayType: typing.Optional[int], index: typing.Optional[int]
    ) -> str: ...
    def Dispose(self) -> None: ...
    def Finish(self) -> None: ...
    @staticmethod
    def FromJsonBagAsync(
        jr: JsonReader, coreVersion: Version, cancellationToken: CancellationToken
    ) -> Task_1[DataArray]: ...
    @staticmethod
    def GetDefaultUnit(type: DataArrayType) -> Unit: ...
    def GetDirection(self, index: int) -> EnumDirection: ...
    def GetEnumerator(self) -> IEnumerator: ...
    def GetIndexArray(self) -> DataArray: ...
    def IndexOf(self, item: IDataValue) -> int: ...
    def Insert(self, index: int, item: IDataValue) -> None: ...
    def OnNewDataAdded(self, nNewValuesAdded: int) -> None: ...
    def Remove(self, item: IDataValue) -> bool: ...
    def RemoveAt(self, index: int) -> None: ...
    def ReplaceContents(self, newDataArray: IEnumerable_1[IDataValue]) -> None: ...
    def SetIndex(self, index: int) -> None: ...
    def Smooth(self, smoothLevel: int, useSmoothLevel: bool = ...) -> bool: ...
    @staticmethod
    def SupportedDefaultUnit(type: DataArrayType) -> bool: ...
    def ToJsonBag(self) -> JsonBag: ...
    def ToJsonWriterAsync(
        self, jw: JsonWriter, cancellationToken: CancellationToken
    ) -> Task: ...
    # Skipped AddRange due to it being static, abstract and generic.

    AddRange: AddRange_MethodGroup
    class AddRange_MethodGroup:
        @typing.overload
        def __call__(self, values: Array_1[float]) -> None: ...
        @typing.overload
        def __call__(self, values: IEnumerable_1[IDataValue]) -> None: ...

    # Skipped CopyTo due to it being static, abstract and generic.

    CopyTo: CopyTo_MethodGroup
    class CopyTo_MethodGroup:
        @typing.overload
        def __call__(self, array: Array_1[IDataValue], arrayIndex: int) -> None: ...
        @typing.overload
        def __call__(
            self, index: int, array: DataArray, arrayIndex: int, count: int
        ) -> None: ...

    # Skipped FromJsonBag due to it being static, abstract and generic.

    FromJsonBag: FromJsonBag_MethodGroup
    class FromJsonBag_MethodGroup:
        @typing.overload
        def __call__(self, bag: JsonBag, coreVersion: Version) -> DataArray: ...
        @typing.overload
        def __call__(
            self, bag: JsonBag, coreVersion: Version, type: DataArrayType
        ) -> DataArray: ...

    # Skipped GetValues due to it being static, abstract and generic.

    GetValues: GetValues_MethodGroup
    class GetValues_MethodGroup:
        @typing.overload
        def __call__(self) -> Array_1[float]: ...
        @typing.overload
        def __call__(self, offset: float) -> Array_1[float]: ...
        # Method GetValues(inverse : Boolean) was skipped since it collides with above method
        @typing.overload
        def __call__(self, offset: float, startIndex: int) -> Array_1[float]: ...
        @typing.overload
        def __call__(
            self, offset: float, startIndex: int, count: int, inverse: bool = ...
        ) -> Array_1[float]: ...

class DataArrayAdmittance(DataArrayFunc):
    @typing.overload
    def __init__(self, bag: JsonBag, coreVersion: Version) -> None: ...
    @typing.overload
    def __init__(
        self, zRe: DataArray, zIm: DataArray, type: DataArrayType, unit: Unit
    ) -> None: ...
    IsFinished: bool
    OCPValue: float
    @property
    def ArrayType(self) -> int: ...
    @property
    def Count(self) -> int: ...
    @property
    def DataValueTypeStr(self) -> str: ...
    @property
    def Description(self) -> str: ...
    @Description.setter
    def Description(self, value: str) -> str: ...
    @property
    def Hidden(self) -> bool: ...
    @Hidden.setter
    def Hidden(self, value: bool) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def Item(self) -> IDataValue: ...
    @Item.setter
    def Item(self, value: IDataValue) -> IDataValue: ...
    @property
    def MaxValue(self) -> float: ...
    @property
    def MinValue(self) -> float: ...
    @property
    def OrgDataArray(self) -> DataArray: ...
    @property
    def Unit(self) -> Unit: ...
    def Dispose(self) -> None: ...

class DataArrayAlreadyExistsException(Exception):
    def __init__(self, message: str) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...

class DataArrayCharge(DataArrayIntegrate):
    @typing.overload
    def __init__(
        self, arrayTime: DataArray, arrayCurrent: DataArray, title: str = ...
    ) -> None: ...
    @typing.overload
    def __init__(self, bag: JsonBag, coreVersion: Version) -> None: ...
    IsFinished: bool
    OCPValue: float
    @property
    def ArrayType(self) -> int: ...
    @property
    def Count(self) -> int: ...
    @property
    def CurrentArray(self) -> DataArrayCurrents: ...
    @property
    def DataValueTypeStr(self) -> str: ...
    @property
    def Description(self) -> str: ...
    @Description.setter
    def Description(self, value: str) -> str: ...
    @property
    def Hidden(self) -> bool: ...
    @Hidden.setter
    def Hidden(self, value: bool) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def Item(self) -> IDataValue: ...
    @Item.setter
    def Item(self, value: IDataValue) -> IDataValue: ...
    @property
    def MaxValue(self) -> float: ...
    @property
    def MinValue(self) -> float: ...
    @property
    def OrgDataArray(self) -> DataArray: ...
    @property
    def Unit(self) -> Unit: ...

class DataArrayCurrents(DataArray):
    @typing.overload
    def __init__(self, bag: JsonBag, coreVersion: Version) -> None: ...
    @typing.overload
    def __init__(self, description: str = ..., arrayType: DataArrayType = ...) -> None: ...
    IsFinished: bool
    OCPValue: float
    @property
    def ArrayType(self) -> int: ...
    @property
    def Count(self) -> int: ...
    @property
    def DataValueTypeStr(self) -> str: ...
    @property
    def Description(self) -> str: ...
    @Description.setter
    def Description(self, value: str) -> str: ...
    @property
    def Hidden(self) -> bool: ...
    @Hidden.setter
    def Hidden(self, value: bool) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def Item(self) -> IDataValue: ...
    @Item.setter
    def Item(self, value: IDataValue) -> IDataValue: ...
    @property
    def MaxValue(self) -> float: ...
    @property
    def MinValue(self) -> float: ...
    @property
    def NOverloads(self) -> int: ...
    @property
    def NOverSteps(self) -> int: ...
    @property
    def NUnderloads(self) -> int: ...
    @property
    def Unit(self) -> Unit: ...
    def Add(self, value: IDataValue) -> None: ...
    def AddRange(self, values: IEnumerable_1[IDataValue]) -> None: ...
    def Clear(self) -> None: ...
    def GetValue(self, index: int) -> CurrentReading: ...

class DataArrayCustomFunc(DataArrayFunc):
    @typing.overload
    def __init__(self, bag: JsonBag, coreVersion: Version) -> None: ...
    @typing.overload
    def __init__(
        self,
        description: str,
        convertPoint: Func_3[Array_1[DataArray], int, IDataValue],
        baseArrays: Array_1[DataArray],
        unit: Unit,
        arrayType: DataArrayType,
    ) -> None: ...
    @typing.overload
    def __init__(
        self,
        description: str,
        sourceArray: DataArray,
        convertPoint: Func_3[Array_1[DataArray], int, IDataValue],
        baseArrays: Array_1[DataArray],
        unit: Unit,
    ) -> None: ...
    IsFinished: bool
    OCPValue: float
    @property
    def ArrayType(self) -> int: ...
    @property
    def Count(self) -> int: ...
    @property
    def DataValueTypeStr(self) -> str: ...
    @property
    def Description(self) -> str: ...
    @Description.setter
    def Description(self, value: str) -> str: ...
    @property
    def Hidden(self) -> bool: ...
    @Hidden.setter
    def Hidden(self, value: bool) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def Item(self) -> IDataValue: ...
    @Item.setter
    def Item(self, value: IDataValue) -> IDataValue: ...
    @property
    def MaxValue(self) -> float: ...
    @property
    def MinValue(self) -> float: ...
    @property
    def OrgDataArray(self) -> DataArray: ...
    @property
    def Unit(self) -> Unit: ...
    def Dispose(self) -> None: ...
    def Init(
        self,
        convertPoint: Func_3[Array_1[DataArray], int, IDataValue],
        baseArrays: Array_1[DataArray],
    ) -> None: ...

class DataArrayDerivative(DataArrayFunc):
    def __init__(self, bag: JsonBag, coreVersion: Version) -> None: ...
    IsFinished: bool
    OCPValue: float
    @property
    def ArrayType(self) -> int: ...
    @property
    def Count(self) -> int: ...
    @property
    def DataValueTypeStr(self) -> str: ...
    @property
    def Description(self) -> str: ...
    @Description.setter
    def Description(self, value: str) -> str: ...
    @property
    def Hidden(self) -> bool: ...
    @Hidden.setter
    def Hidden(self, value: bool) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def Item(self) -> IDataValue: ...
    @Item.setter
    def Item(self, value: IDataValue) -> IDataValue: ...
    @property
    def MaxValue(self) -> float: ...
    @property
    def MinValue(self) -> float: ...
    @property
    def OrgDataArray(self) -> DataArray: ...
    @property
    def Unit(self) -> Unit: ...
    def Dispose(self) -> None: ...
    def Finish(self) -> None: ...
    @staticmethod
    def GetDataArrayDerivative(xDataArray: DataArray, yDataArray: DataArray) -> DataArray: ...

class DataArrayFunc(DataArray, abc.ABC):
    @typing.overload
    def __init__(self, bag: JsonBag, coreVersion: Version) -> None: ...
    @typing.overload
    def __init__(self, orgDataArray: DataArray, newUnit: Unit) -> None: ...
    IsFinished: bool
    OCPValue: float
    @property
    def ArrayType(self) -> int: ...
    @property
    def Count(self) -> int: ...
    @property
    def DataValueTypeStr(self) -> str: ...
    @property
    def Description(self) -> str: ...
    @Description.setter
    def Description(self, value: str) -> str: ...
    @property
    def Hidden(self) -> bool: ...
    @Hidden.setter
    def Hidden(self, value: bool) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def Item(self) -> IDataValue: ...
    @Item.setter
    def Item(self, value: IDataValue) -> IDataValue: ...
    @property
    def MaxValue(self) -> float: ...
    @property
    def MinValue(self) -> float: ...
    @property
    def OrgDataArray(self) -> DataArray: ...
    @property
    def Unit(self) -> Unit: ...
    def OnFuncDataAdded(self, startIndex: int, nNewValuesAdded: int) -> None: ...
    def OnNewDataAdded(self, nNewValuesAdded: int) -> None: ...

class DataArrayIntegrate(DataArrayFunc):
    @typing.overload
    def __init__(self, arrayX: DataArray, arrayY: DataArray, unit: Unit) -> None: ...
    @typing.overload
    def __init__(self, bag: JsonBag, coreVersion: Version) -> None: ...
    IsFinished: bool
    OCPValue: float
    @property
    def ArrayType(self) -> int: ...
    @property
    def Count(self) -> int: ...
    @property
    def DataValueTypeStr(self) -> str: ...
    @property
    def Description(self) -> str: ...
    @Description.setter
    def Description(self, value: str) -> str: ...
    @property
    def Hidden(self) -> bool: ...
    @Hidden.setter
    def Hidden(self, value: bool) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def Item(self) -> IDataValue: ...
    @Item.setter
    def Item(self, value: IDataValue) -> IDataValue: ...
    @property
    def MaxValue(self) -> float: ...
    @property
    def MinValue(self) -> float: ...
    @property
    def OrgDataArray(self) -> DataArray: ...
    @property
    def Unit(self) -> Unit: ...
    def Dispose(self) -> None: ...
    @staticmethod
    def GetDataArrayIntegrate(dataArrayX: DataArray, dataArrayY: DataArray) -> DataArray: ...

class DataArrayLog(DataArrayFunc):
    def __init__(self, bag: JsonBag, coreVersion: Version) -> None: ...
    IsFinished: bool
    OCPValue: float
    @property
    def ArrayType(self) -> int: ...
    @property
    def Count(self) -> int: ...
    @property
    def DataValueTypeStr(self) -> str: ...
    @property
    def Description(self) -> str: ...
    @Description.setter
    def Description(self, value: str) -> str: ...
    @property
    def Hidden(self) -> bool: ...
    @Hidden.setter
    def Hidden(self, value: bool) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def Item(self) -> IDataValue: ...
    @Item.setter
    def Item(self, value: IDataValue) -> IDataValue: ...
    @property
    def MaxValue(self) -> float: ...
    @property
    def MinValue(self) -> float: ...
    @property
    def OrgDataArray(self) -> DataArray: ...
    @property
    def Unit(self) -> Unit: ...
    def Dispose(self) -> None: ...
    @staticmethod
    def GetDataArrayLog(sourceArray: DataArray) -> DataArray: ...

class DataArrayPotentials(DataArray):
    @typing.overload
    def __init__(self, bag: JsonBag, coreVersion: Version) -> None: ...
    @typing.overload
    def __init__(self, description: str = ..., arrayType: DataArrayType = ...) -> None: ...
    IsFinished: bool
    OCPValue: float
    @property
    def ArrayType(self) -> int: ...
    @property
    def Count(self) -> int: ...
    @property
    def DataValueTypeStr(self) -> str: ...
    @property
    def Description(self) -> str: ...
    @Description.setter
    def Description(self, value: str) -> str: ...
    @property
    def Hidden(self) -> bool: ...
    @Hidden.setter
    def Hidden(self, value: bool) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def Item(self) -> IDataValue: ...
    @Item.setter
    def Item(self, value: IDataValue) -> IDataValue: ...
    @property
    def MaxValue(self) -> float: ...
    @property
    def MinValue(self) -> float: ...
    @property
    def NOverloads(self) -> int: ...
    @property
    def NOverSteps(self) -> int: ...
    @property
    def NUnderloads(self) -> int: ...
    @property
    def Unit(self) -> Unit: ...
    def Add(self, value: IDataValue) -> None: ...
    def AddRange(self, values: IEnumerable_1[IDataValue]) -> None: ...

class DataArraySecondDerivative(DataArrayFunc):
    IsFinished: bool
    OCPValue: float
    @property
    def ArrayType(self) -> int: ...
    @property
    def Count(self) -> int: ...
    @property
    def DataValueTypeStr(self) -> str: ...
    @property
    def Description(self) -> str: ...
    @Description.setter
    def Description(self, value: str) -> str: ...
    @property
    def Hidden(self) -> bool: ...
    @Hidden.setter
    def Hidden(self, value: bool) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def Item(self) -> IDataValue: ...
    @Item.setter
    def Item(self, value: IDataValue) -> IDataValue: ...
    @property
    def MaxValue(self) -> float: ...
    @property
    def MinValue(self) -> float: ...
    @property
    def OrgDataArray(self) -> DataArray: ...
    @property
    def Unit(self) -> Unit: ...
    def Dispose(self) -> None: ...
    def Finish(self) -> None: ...
    @staticmethod
    def GetDataArraySecondDerivative(
        xDataArray: DataArray, yDataArray: DataArray
    ) -> DataArray: ...

class DataArrayTime(DataArray):
    @typing.overload
    def __init__(self, bag: JsonBag, coreVersion: Version) -> None: ...
    @typing.overload
    def __init__(self, description: str = ...) -> None: ...
    IsFinished: bool
    OCPValue: float
    @property
    def ArrayType(self) -> int: ...
    @property
    def Count(self) -> int: ...
    @property
    def DataValueTypeStr(self) -> str: ...
    @property
    def Description(self) -> str: ...
    @Description.setter
    def Description(self, value: str) -> str: ...
    @property
    def Hidden(self) -> bool: ...
    @Hidden.setter
    def Hidden(self, value: bool) -> bool: ...
    @property
    def IntervalTime(self) -> float: ...
    @IntervalTime.setter
    def IntervalTime(self, value: float) -> float: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def Item(self) -> IDataValue: ...
    @Item.setter
    def Item(self, value: IDataValue) -> IDataValue: ...
    @property
    def MaxValue(self) -> float: ...
    @property
    def MinValue(self) -> float: ...
    @property
    def Unit(self) -> Unit: ...

class DataArrayType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Time: DataArrayType  # 0
    Potential: DataArrayType  # 1
    Current: DataArrayType  # 2
    Charge: DataArrayType  # 3
    ExtraValue: DataArrayType  # 4
    Frequency: DataArrayType  # 5
    Phase: DataArrayType  # 6
    ZRe: DataArrayType  # 7
    ZIm: DataArrayType  # 8
    Iac: DataArrayType  # 9
    Z: DataArrayType  # 10
    Y: DataArrayType  # 11
    YRe: DataArrayType  # 12
    YIm: DataArrayType  # 13
    Cs: DataArrayType  # 14
    CsRe: DataArrayType  # 15
    CsIm: DataArrayType  # 16
    Index: DataArrayType  # 17
    Admittance: DataArrayType  # 18
    Concentration: DataArrayType  # 19
    Signal: DataArrayType  # 20
    Func: DataArrayType  # 21
    Integral: DataArrayType  # 22
    AuxInput: DataArrayType  # 23
    BipotCurrent: DataArrayType  # 24
    BipotPotential: DataArrayType  # 25
    ReverseCurrent: DataArrayType  # 26
    CEPotential: DataArrayType  # 27
    DCCurrent: DataArrayType  # 28
    ForwardCurrent: DataArrayType  # 29
    PotentialExtraRE: DataArrayType  # 30
    CurrentExtraWE: DataArrayType  # 31
    InverseDerative_dtdE: DataArrayType  # 32
    mEdc: DataArrayType  # 33
    Eac: DataArrayType  # 34
    MeasuredStepStartIndex: DataArrayType  # 35
    miDC: DataArrayType  # 36
    SE2vsXPotential: DataArrayType  # 37
    nPointsAC: DataArrayType  # 16383
    realtintac: DataArrayType  # 16384
    ymean: DataArrayType  # 16385
    debugtext: DataArrayType  # 16386
    Generic: DataArrayType  # 32767
    None_: DataArrayType  # -1

class DataSet(IEnumerable_1[DataArray], IDisposable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, bag: JsonBag, coreVersion: Version) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def IsFinished(self) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def NPoints(self) -> int: ...
    def AddDataArray(self, newArray: DataArray) -> DataArray: ...
    def Clear(self) -> None: ...
    def Contains(self, item: DataArray) -> bool: ...
    def CopyTo(self, array: Array_1[DataArray], arrayIndex: int) -> None: ...
    def Dispose(self) -> None: ...
    def Finish(self) -> None: ...
    @staticmethod
    def FromJsonBag(bag: JsonBag, coreVersion: Version) -> DataSet: ...
    @staticmethod
    def FromJsonBagAsync(
        jr: JsonReader, coreVersion: Version, cancellationToken: CancellationToken
    ) -> Task_1[DataSet]: ...
    def IndexOf(self, item: DataArray) -> int: ...
    def Insert(self, index: int, item: DataArray) -> None: ...
    def Remove(self, item: DataArray) -> bool: ...
    def RemoveAt(self, index: int) -> None: ...
    def RemoveDataPointFromAllArrays(self, index: int) -> None: ...
    def ToJsonBag(self) -> JsonBag: ...
    def ToJsonWriterAsync(
        self, jw: JsonWriter, cancellationToken: CancellationToken
    ) -> Task: ...
    # Skipped ContainsArrayType due to it being static, abstract and generic.

    ContainsArrayType: ContainsArrayType_MethodGroup
    class ContainsArrayType_MethodGroup:
        @typing.overload
        def __call__(self, arrayType: int) -> bool: ...
        @typing.overload
        def __call__(self, arrayType: DataArrayType) -> bool: ...

    # Skipped GetDataArrays due to it being static, abstract and generic.

    GetDataArrays: GetDataArrays_MethodGroup
    class GetDataArrays_MethodGroup:
        @typing.overload
        def __call__(self) -> Array_1[DataArray]: ...
        @typing.overload
        def __call__(self, arrayType: int) -> Array_1[DataArray]: ...
        @typing.overload
        def __call__(self, arrayType: DataArrayType) -> Array_1[DataArray]: ...

    # Skipped GetLastOfType due to it being static, abstract and generic.

    GetLastOfType: GetLastOfType_MethodGroup
    class GetLastOfType_MethodGroup:
        @typing.overload
        def __call__(self, arrayType: int) -> DataArray: ...
        @typing.overload
        def __call__(self, arrayType: DataArrayType) -> DataArray: ...

    # Skipped OnNewDataAdded due to it being static, abstract and generic.

    OnNewDataAdded: OnNewDataAdded_MethodGroup
    class OnNewDataAdded_MethodGroup:
        @typing.overload
        def __call__(self, nNewValues: int) -> None: ...
        @typing.overload
        def __call__(self, nNewValues: int, arrays: List_1[DataArray]) -> None: ...

    # Skipped RemoveType due to it being static, abstract and generic.

    RemoveType: RemoveType_MethodGroup
    class RemoveType_MethodGroup:
        @typing.overload
        def __call__(self, arrayType: int) -> None: ...
        @typing.overload
        def __call__(self, arrayType: DataArrayType) -> None: ...

class DataSetCommon(DataSet):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, bag: JsonBag, coreVersion: Version) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def IsFinished(self) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def NPoints(self) -> int: ...
    def Clone(self) -> DataSetCommon: ...
    def GetLastAuxInputValueDataArray(self) -> DataArray: ...
    def GetLastChargeDataArray(self) -> DataArrayCharge: ...
    def GetLastCurrentDataArray(self) -> DataArrayCurrents: ...
    def GetLastPotentialDataArray(self) -> DataArrayPotentials: ...
    def GetLastTimeDataArray(self) -> DataArrayTime: ...
    def ToJsonBag(self) -> JsonBag: ...

class DataSetEIS(DataSetCommon):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, bag: JsonBag, coreVersion: Version) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def IsFinished(self) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def NPoints(self) -> int: ...
    def AddDerivedDataArrays(self) -> None: ...
    @staticmethod
    def DataSetEISFromJson(
        jr: JsonReader, coreVersion: Version, cancellationToken: CancellationToken
    ) -> Task_1[DataSet]: ...

class DataValueFactory(abc.ABC):
    @staticmethod
    def FromJsonBag(bag: JsonBag, coreVersion: Version, typeStr: str) -> IDataValue: ...

class DeviceFile:
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, dir: str, rawStr: str, formatVersion: int, utc: bool = ...) -> None: ...
    @typing.overload
    def __init__(self, path: str, formatVersion: int) -> None: ...
    Dir: str
    Name: str
    Root: DeviceFile
    Size: int
    Timestamp: DateTime
    Type: DeviceFileType
    @property
    def Content(self) -> str: ...
    @Content.setter
    def Content(self, value: str) -> str: ...

class DeviceFileType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Measurement: DeviceFileType  # 0
    Folder: DeviceFileType  # 1

class EnumAxes(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Xaxis: EnumAxes  # 0
    Yaxis: EnumAxes  # 1
    Zaxis: EnumAxes  # 2

class EnumDirection(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Ascending: EnumDirection  # 1
    Descending: EnumDirection  # -1

class GenericValue(IDataValue):
    @typing.overload
    def __init__(self, bag: JsonBag, coreVersion: Version) -> None: ...
    @typing.overload
    def __init__(self, value: float) -> None: ...
    @typing.overload
    def __init__(self, value: float, text: str) -> None: ...
    @property
    def Text(self) -> str: ...
    @Text.setter
    def Text(self, value: str) -> str: ...
    @property
    def Value(self) -> float: ...
    @Value.setter
    def Value(self, value: float) -> float: ...
    def Copy(self) -> IDataValue: ...
    @staticmethod
    def GenericValueFromJson(jr: JsonReader) -> Task_1[IDataValue]: ...
    def GetFormattedValue(self) -> str: ...
    def ToJsonBag(self) -> JsonBag: ...
    def ToJsonWriter(self, jw: JsonWriter, cancellationToken: CancellationToken) -> Task: ...

class IDataValue(typing.Protocol):
    @property
    def Text(self) -> str: ...
    @Text.setter
    def Text(self, value: str) -> str: ...
    @property
    def Value(self) -> float: ...
    @Value.setter
    def Value(self, value: float) -> float: ...
    @abc.abstractmethod
    def Copy(self) -> IDataValue: ...
    @abc.abstractmethod
    def GetFormattedValue(self) -> str: ...
    @abc.abstractmethod
    def ToJsonBag(self) -> JsonBag: ...
    @abc.abstractmethod
    def ToJsonWriter(self, jw: JsonWriter, cancellationToken: CancellationToken) -> Task: ...

class IncompatibleDataArrayException(Exception):
    def __init__(self, message: str) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...

class ISessionManager(typing.Protocol):
    @property
    def MethodForEditor(self) -> Method: ...
    @MethodForEditor.setter
    def MethodForEditor(self, value: Method) -> Method: ...
    @abc.abstractmethod
    def AddMeasurement(
        self, loadAnalysisFile: Measurement, silent: bool = ..., noPeaks: bool = ...
    ) -> None: ...
    @abc.abstractmethod
    def Load(self, curveFile: SessionFile, filePath: str, add: bool) -> None: ...

class LevelDetectEventArgs(EventArgs):
    def __init__(self, levelDetectProgress: LevelDetectProgress) -> None: ...
    LevelDetectProgress: LevelDetectProgress

class LevelDetectHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(
        self,
        sender: typing.Any,
        e: LevelDetectEventArgs,
        callback: AsyncCallback,
        object: typing.Any,
    ) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: LevelDetectEventArgs) -> None: ...

class LoadCurveColorAssignement(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Default: LoadCurveColorAssignement  # 0
    Force: LoadCurveColorAssignement  # 1
    Ignore: LoadCurveColorAssignement  # 2

class MeasurementHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(
        self,
        sender: typing.Any,
        e: MeasurementsChangedEventArgs,
        callback: AsyncCallback,
        object: typing.Any,
    ) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: MeasurementsChangedEventArgs) -> None: ...

class MeasurementsChangedEventArgs(EventArgs):
    def __init__(self, measurements: Array_1[Measurement]) -> None: ...
    ChangedMeasurements: Array_1[Measurement]

class PeakDetectEventArgs(EventArgs):
    def __init__(self, peakDetectProgress: PeakDetectProgress) -> None: ...
    PeakDetectProgress: PeakDetectProgress

class PeakDetectHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(
        self,
        sender: typing.Any,
        e: PeakDetectEventArgs,
        callback: AsyncCallback,
        object: typing.Any,
    ) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: PeakDetectEventArgs) -> None: ...

class SessionManager(IEnumerable_1[Measurement], IDisposable, ISessionManager):
    def __init__(self) -> None: ...

    class CurveMeasTypeChangedEventHandler(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(
            self, c: Curve, measType: MeasType, callback: AsyncCallback, object: typing.Any
        ) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, c: Curve, measType: MeasType) -> None: ...

    class ModesPSTrace(typing.SupportsInt):
        @typing.overload
        def __init__(self, value: int) -> None: ...
        @typing.overload
        def __init__(self, value: int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...

        # Values:
        Scientific: SessionManager.ModesPSTrace  # 0
        Analytical: SessionManager.ModesPSTrace  # 1
        Corrosion: SessionManager.ModesPSTrace  # 2

    class SelectableDataTypes(typing.SupportsInt):
        @typing.overload
        def __init__(self, value: int) -> None: ...
        @typing.overload
        def __init__(self, value: int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...

        # Values:
        CurveData: SessionManager.SelectableDataTypes  # 0
        EisData: SessionManager.SelectableDataTypes  # 1
        MeasurementData: SessionManager.SelectableDataTypes  # 2

    CurveCollection: Dictionary_2[Curve, Measurement]
    EISDataCollection: Dictionary_2[EISData, Measurement]
    FindPeakShoulders: bool
    MergeOverlappingPeaks: bool
    PSTraceMode: SessionManager.ModesPSTrace
    UseBlankIfAvailable: bool
    UserSelectedDataType: SessionManager.SelectableDataTypes
    @property
    def AppendDateTimeToMeasurementTitleOnLoad(self) -> bool: ...
    @AppendDateTimeToMeasurementTitleOnLoad.setter
    def AppendDateTimeToMeasurementTitleOnLoad(self, value: bool) -> bool: ...
    @property
    def AutoPeaks(self) -> bool: ...
    @AutoPeaks.setter
    def AutoPeaks(self, value: bool) -> bool: ...
    @property
    def ColorAssignementOnLoad(self) -> LoadCurveColorAssignement: ...
    @ColorAssignementOnLoad.setter
    def ColorAssignementOnLoad(
        self, value: LoadCurveColorAssignement
    ) -> LoadCurveColorAssignement: ...
    @property
    def Count(self) -> int: ...
    @property
    def DisableCorePeakDetection(self) -> bool: ...
    @DisableCorePeakDetection.setter
    def DisableCorePeakDetection(self, value: bool) -> bool: ...
    @property
    def Item(self) -> Measurement: ...
    @property
    def Measurements(self) -> List_1[Measurement]: ...
    @property
    def MethodForEditor(self) -> Method: ...
    @MethodForEditor.setter
    def MethodForEditor(self, value: Method) -> Method: ...
    @property
    def SavedToSession(self) -> bool: ...
    @SavedToSession.setter
    def SavedToSession(self, value: bool) -> bool: ...
    @property
    def SelectedCurve(self) -> Curve: ...
    @SelectedCurve.setter
    def SelectedCurve(self, value: Curve) -> Curve: ...
    @property
    def SelectedEISData(self) -> EISData: ...
    @SelectedEISData.setter
    def SelectedEISData(self, value: EISData) -> EISData: ...
    @property
    def SelectedMeasurement(self) -> Measurement: ...
    @SelectedMeasurement.setter
    def SelectedMeasurement(self, value: Measurement) -> Measurement: ...
    def AddMeasurement(
        self, m: Measurement, silent: bool = ..., noPeaks: bool = ...
    ) -> None: ...
    def AddMeasurements(
        self, measurements: Array_1[Measurement], silent: bool = ...
    ) -> None: ...
    @staticmethod
    def AppendDateTimeToMeasurementTitle(measurements: Array_1[Measurement]) -> None: ...
    def ClearMeasurements(self) -> None: ...
    def Dispose(self) -> None: ...
    def FindPeaksOrLevelsInAllMeasurements(self, forceAdd: bool = ...) -> None: ...
    def FindPeaksOrLevelsInSelectedCurve(self, forceAdd: bool = ...) -> None: ...
    def GetAllCurves(self) -> IList_1[Curve]: ...
    def GetAllEISData(self) -> IList_1[EISData]: ...
    def GetAvailableAnalysisCurvesCount(self) -> int: ...
    def GetCollection(self) -> Array_1[Measurement]: ...
    def GetCurveForMeasType(self, measType: MeasType) -> Curve: ...
    def GetEnumerator(self) -> IEnumerator_1[Measurement]: ...
    def GetMeasurementForCurve(self, c: Curve) -> Measurement: ...
    def GetMeasurementForEISData(self, eisData: EISData) -> Measurement: ...
    def LoadAsync(
        self,
        fileStream: Stream,
        filepath: str,
        cancellationToken: CancellationToken,
        add: bool = ...,
    ) -> Task: ...
    def LoadFilesAsync(
        self, filepath: str, cancellationToken: CancellationToken
    ) -> Task_1[SessionFile]: ...
    def OrderMeasurements(self) -> None: ...
    def RemoveAllMeasurementsWithCurves(self) -> None: ...
    def RemoveAllMeasurementsWithEIS(self) -> None: ...
    def RemoveAllPeaksOrLevels(self) -> None: ...
    def RemoveAllPeaksOrLevelsSelectedCurve(self) -> None: ...
    def RemoveCurves(self, curves: Array_1[Curve], deleteEmptyMeasurement: bool) -> None: ...
    def RemoveEISData(
        self, eisDatas: Array_1[EISData], deleteEmptyMeasurement: bool
    ) -> None: ...
    def RemoveMeasurement(
        self, m: Measurement, triggerAvailableDataChanged: bool = ...
    ) -> None: ...
    def RemoveMeasurements(
        self, measurements: IEnumerable_1[Measurement], triggerAvailableDataChanged: bool = ...
    ) -> None: ...
    def Save(self, fileStream: Stream, filepath: str) -> None: ...
    def SaveAsync(
        self,
        fileStream: Stream,
        filepath: str,
        cancellationToken: CancellationToken,
        progress: IProgress_1[bool],
    ) -> Task: ...
    def SetCurveMeasType(self, measType: MeasType, curve: Curve) -> None: ...
    def SetCurveTitle(self, c: Curve) -> None: ...
    def SetEISDataTitle(self, eisData: EISData) -> None: ...
    # Skipped Load due to it being static, abstract and generic.

    Load: Load_MethodGroup
    class Load_MethodGroup:
        @typing.overload
        def __call__(self, fileStream: Stream, filepath: str, add: bool = ...) -> None: ...
        @typing.overload
        def __call__(self, file: SessionFile, filepath: str, add: bool) -> None: ...

class VoltageReading(IDataValue):
    @typing.overload
    def __init__(self, bag: JsonBag, coreVersion: Version) -> None: ...
    @typing.overload
    def __init__(self, status: ReadingStatus, timingStatus: TimingStatus = ...) -> None: ...
    @typing.overload
    def __init__(
        self,
        value: float,
        status: ReadingStatus,
        range: PotentialRange = ...,
        timingStatus: TimingStatus = ...,
    ) -> None: ...
    Range: PotentialRange
    ReadingStatus: ReadingStatus
    TimingStatus: TimingStatus
    @property
    def Text(self) -> str: ...
    @Text.setter
    def Text(self, value: str) -> str: ...
    @property
    def Value(self) -> float: ...
    @Value.setter
    def Value(self, value: float) -> float: ...
    @property
    def ValueInRange(self) -> float: ...
    def Copy(self) -> IDataValue: ...
    def GetFormattedValue(self) -> str: ...
    def ToJsonBag(self) -> JsonBag: ...
    def ToJsonWriter(self, jw: JsonWriter, cancellationToken: CancellationToken) -> Task: ...
