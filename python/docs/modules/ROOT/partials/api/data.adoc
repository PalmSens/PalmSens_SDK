== pypalmsens.data

This module contains the public api for classes representing measurement
data.

*Classes:*

* link:#pypalmsens.data.ArrayType[*ArrayType*] – Data array type for
standard arrays.
* link:#pypalmsens.data.DataArray[*DataArray*] – Python wrapper for .NET
DataArray class.
* link:#pypalmsens.data.Peak[*Peak*] – Python wrapper for .NET Peak
class.
* link:#pypalmsens.data.DeviceInfo[*DeviceInfo*] – Dataclass for device
information.
* link:#pypalmsens.data.Curve[*Curve*] – Python wrapper for .NET Curve
class.
* link:#pypalmsens.data.Measurement[*Measurement*] – Python wrapper for
.NET Measurement class.
* link:#pypalmsens.data.DataSet[*DataSet*] – Python wrapper for .NET
DataSet class.
* link:#pypalmsens.data.EISData[*EISData*] – Python wrapper for .NET
EISdata class.

=== ArrayType

Data array type for standard arrays.

*Attributes:*

* link:#pypalmsens.data.ArrayType.Unspecified[*Unspecified*] –
Unspecified
* link:#pypalmsens.data.ArrayType.Time[*Time*] – Time / s
* link:#pypalmsens.data.ArrayType.Potential[*Potential*] – Potential / V
* link:#pypalmsens.data.ArrayType.Current[*Current*] – Current / μA
* link:#pypalmsens.data.ArrayType.Charge[*Charge*] – Charge
* link:#pypalmsens.data.ArrayType.ExtraValue[*ExtraValue*] – ExtraValue
* link:#pypalmsens.data.ArrayType.Frequency[*Frequency*] – Frequency
* link:#pypalmsens.data.ArrayType.Phase[*Phase*] – Phase
* link:#pypalmsens.data.ArrayType.ZRe[*ZRe*] – Z real
* link:#pypalmsens.data.ArrayType.ZIm[*ZIm*] – Z imaginary
* link:#pypalmsens.data.ArrayType.Iac[*Iac*] – I AC values
* link:#pypalmsens.data.ArrayType.Z[*Z*] – Z
* link:#pypalmsens.data.ArrayType.Y[*Y*] – Y
* link:#pypalmsens.data.ArrayType.YRe[*YRe*] – Y real
* link:#pypalmsens.data.ArrayType.YIm[*YIm*] – Y imaginary
* link:#pypalmsens.data.ArrayType.Cs[*Cs*] – Cs
* link:#pypalmsens.data.ArrayType.CsRe[*CsRe*] – Cs real
* link:#pypalmsens.data.ArrayType.CsIm[*CsIm*] – Cs imaginary
* link:#pypalmsens.data.ArrayType.Index[*Index*] – Index
* link:#pypalmsens.data.ArrayType.Admittance[*Admittance*] – Admittance
* link:#pypalmsens.data.ArrayType.Concentration[*Concentration*] –
Concentration
* link:#pypalmsens.data.ArrayType.Signal[*Signal*] – Signal
* link:#pypalmsens.data.ArrayType.Func[*Func*] – Func
* link:#pypalmsens.data.ArrayType.Integral[*Integral*] – Integral
* link:#pypalmsens.data.ArrayType.AuxInput[*AuxInput*] – Auxillary input
* link:#pypalmsens.data.ArrayType.BipotCurrent[*BipotCurrent*] – Bipot
current
* link:#pypalmsens.data.ArrayType.BipotPotential[*BipotPotential*] –
Bipot potential
* link:#pypalmsens.data.ArrayType.ReverseCurrent[*ReverseCurrent*] –
Reverse current
* link:#pypalmsens.data.ArrayType.CEPotential[*CEPotential*] – CE
potential
* link:#pypalmsens.data.ArrayType.DCCurrent[*DCCurrent*] – DC current
* link:#pypalmsens.data.ArrayType.ForwardCurrent[*ForwardCurrent*] –
Forward current
* link:#pypalmsens.data.ArrayType.PotentialExtraRE[*PotentialExtraRE*] –
Potential setpoint measured back on RE
* link:#pypalmsens.data.ArrayType.CurrentExtraWE[*CurrentExtraWE*] –
Current setpoint measured back on WE
* link:#pypalmsens.data.ArrayType.InverseDerative_dtdE[*InverseDerative_dtdE*]
– Inverse derivative dt/dE
* link:#pypalmsens.data.ArrayType.mEdc[*mEdc*] – Measured applied DC
* link:#pypalmsens.data.ArrayType.Eac[*Eac*] – E AC values
* link:#pypalmsens.data.ArrayType.MeasuredStepStartIndex[*MeasuredStepStartIndex*]
– MeasuredStepStartIndex
* link:#pypalmsens.data.ArrayType.miDC[*miDC*] – Measured I DC values
* link:#pypalmsens.data.ArrayType.SE2vsXPotential[*SE2vsXPotential*] –
SE2 vs XPotential

==== Unspecified

[source,python]
----
Unspecified = -1
----

Unspecified

==== Time

[source,python]
----
Time = 0
----

Time / s

==== Potential

[source,python]
----
Potential = 1
----

Potential / V

==== Current

[source,python]
----
Current = 2
----

Current / μA

==== Charge

[source,python]
----
Charge = 3
----

Charge

==== ExtraValue

[source,python]
----
ExtraValue = 4
----

ExtraValue

==== Frequency

[source,python]
----
Frequency = 5
----

Frequency

==== Phase

[source,python]
----
Phase = 6
----

Phase

==== ZRe

[source,python]
----
ZRe = 7
----

Z real

==== ZIm

[source,python]
----
ZIm = 8
----

Z imaginary

==== Iac

[source,python]
----
Iac = 9
----

I AC values

==== Z

[source,python]
----
Z = 10
----

Z

==== Y

[source,python]
----
Y = 11
----

Y

==== YRe

[source,python]
----
YRe = 12
----

Y real

==== YIm

[source,python]
----
YIm = 13
----

Y imaginary

==== Cs

[source,python]
----
Cs = 14
----

Cs

==== CsRe

[source,python]
----
CsRe = 15
----

Cs real

==== CsIm

[source,python]
----
CsIm = 16
----

Cs imaginary

==== Index

[source,python]
----
Index = 17
----

Index

==== Admittance

[source,python]
----
Admittance = 18
----

Admittance

==== Concentration

[source,python]
----
Concentration = 19
----

Concentration

==== Signal

[source,python]
----
Signal = 20
----

Signal

==== Func

[source,python]
----
Func = 21
----

Func

==== Integral

[source,python]
----
Integral = 22
----

Integral

==== AuxInput

[source,python]
----
AuxInput = 23
----

Auxillary input

==== BipotCurrent

[source,python]
----
BipotCurrent = 24
----

Bipot current

==== BipotPotential

[source,python]
----
BipotPotential = 25
----

Bipot potential

==== ReverseCurrent

[source,python]
----
ReverseCurrent = 26
----

Reverse current

==== CEPotential

[source,python]
----
CEPotential = 27
----

CE potential

==== DCCurrent

[source,python]
----
DCCurrent = 28
----

DC current

==== ForwardCurrent

[source,python]
----
ForwardCurrent = 29
----

Forward current

==== PotentialExtraRE

[source,python]
----
PotentialExtraRE = 30
----

Potential setpoint measured back on RE

==== CurrentExtraWE

[source,python]
----
CurrentExtraWE = 31
----

Current setpoint measured back on WE

==== InverseDerative_dtdE

[source,python]
----
InverseDerative_dtdE = 32
----

Inverse derivative dt/dE

==== mEdc

[source,python]
----
mEdc = 33
----

Measured applied DC

==== Eac

[source,python]
----
Eac = 34
----

E AC values

==== MeasuredStepStartIndex

[source,python]
----
MeasuredStepStartIndex = 35
----

MeasuredStepStartIndex

==== miDC

[source,python]
----
miDC = 36
----

Measured I DC values

==== SE2vsXPotential

[source,python]
----
SE2vsXPotential = 37
----

SE2 vs XPotential

=== DataArray

[source,python]
----
DataArray(*, psarray)
----

Python wrapper for .NET DataArray class.

*Parameters:*

* *psarray* – Reference to .NET DataArray object.

*Functions:*

* link:#pypalmsens.data.DataArray.copy[*copy*] – Return a copy of the
array.
* link:#pypalmsens.data.DataArray.min[*min*] – Return min value.
* link:#pypalmsens.data.DataArray.max[*max*] – Return max value.
* link:#pypalmsens.data.DataArray.savitsky_golay[*savitsky_golay*] –
Smooth the array using a Savitsky-Golay filter with the window size.
* link:#pypalmsens.data.DataArray.to_numpy[*to_numpy*] – Export data
array to numpy.
* link:#pypalmsens.data.DataArray.to_list[*to_list*] – Export data array
to list.

*Attributes:*

* link:#pypalmsens.data.DataArray.name[*name*] (link:#str[str]) – Name
of the array.
* link:#pypalmsens.data.DataArray.type[*type*]
(link:#pypalmsens._data._shared.ArrayType[ArrayType]) – ArrayType enum.
* link:#pypalmsens.data.DataArray.unit[*unit*] (link:#str[str]) – Unit
for array.
* link:#pypalmsens.data.DataArray.quantity[*quantity*] (link:#str[str])
– Quantity for array.
* link:#pypalmsens.data.DataArray.ocp_value[*ocp_value*]
(link:#float[float]) – OCP Value.

==== name

[source,python]
----
name: str
----

Name of the array.

==== type

[source,python]
----
type: ArrayType
----

ArrayType enum.

==== unit

[source,python]
----
unit: str
----

Unit for array.

==== quantity

[source,python]
----
quantity: str
----

Quantity for array.

==== ocp_value

[source,python]
----
ocp_value: float
----

OCP Value.

==== copy

[source,python]
----
copy()
----

Return a copy of the array.

==== min

[source,python]
----
min()
----

Return min value.

==== max

[source,python]
----
max()
----

Return max value.

==== savitsky_golay

[source,python]
----
savitsky_golay(window_size=3)
----

Smooth the array using a Savitsky-Golay filter with the window size.

(i.e. window size 2 will filter points based on the values of the
next/previous 2 points)

*Parameters:*

* *window_size* (link:#int[int]) – Size of the window

==== to_numpy

[source,python]
----
to_numpy()
----

Export data array to numpy.

==== to_list

[source,python]
----
to_list()
----

Export data array to list.

=== Peak

[source,python]
----
Peak(*, pspeak)
----

Python wrapper for .NET Peak class.

*Parameters:*

* *pspeak* (link:#PalmSens.Analysis.Peak[Peak]) – Reference to .NET Peak
object.

*Attributes:*

* link:#pypalmsens.data.Peak.curve[*curve*]
(link:#pypalmsens._data.curve.Curve[Curve]) – Parent curve associated
with Peak.
* link:#pypalmsens.data.Peak.curve_title[*curve_title*] (link:#str[str])
– Title of parent curve.
* link:#pypalmsens.data.Peak.x_unit[*x_unit*] (link:#str[str]) – Units
of X axis
* link:#pypalmsens.data.Peak.y_unit[*y_unit*] (link:#str[str]) – Units
for Y axis
* link:#pypalmsens.data.Peak.analyte_name[*analyte_name*]
(link:#str[str]) – Name of analyte.
* link:#pypalmsens.data.Peak.area[*area*] (link:#float[float]) – Area of
the peak.
* link:#pypalmsens.data.Peak.label[*label*] (link:#str[str]) – Formatted
label for the peak value.
* link:#pypalmsens.data.Peak.left_index[*left_index*] (link:#int[int]) –
Left side of the peaks baseline as index number of the curve.
* link:#pypalmsens.data.Peak.left_x[*left_x*] (link:#float[float]) – X
of the left side of the peak baseline.
* link:#pypalmsens.data.Peak.left_y[*left_y*] (link:#float[float]) – Y
of the left side of the peak baseline.
* link:#pypalmsens.data.Peak.maximum_of_derivative_neg[*maximum_of_derivative_neg*]
(link:#float[float]) – Maximum derivative of the negative slope of the
peak.
* link:#pypalmsens.data.Peak.maximum_of_derivative_pos[*maximum_of_derivative_pos*]
(link:#float[float]) – Maximum derivative of the positive slope of the
peak.
* link:#pypalmsens.data.Peak.maximum_of_derivative_sum[*maximum_of_derivative_sum*]
(link:#float[float]) – Sum of the absolute values for both the positive
and negative maximum derivative.
* link:#pypalmsens.data.Peak.notes[*notes*] (link:#str[str]) – User
notes stored on this peak.
* link:#pypalmsens.data.Peak.y_offset[*y_offset*] (link:#float[float]) –
Offset of Y.
* link:#pypalmsens.data.Peak.index[*index*] (link:#int[int]) – Location
of the peak as index number of the curve.
* link:#pypalmsens.data.Peak.type[*type*] (link:#str[str]) – Used to
determine if a peak is auto found.
* link:#pypalmsens.data.Peak.value[*value*] (link:#float[float]) – Value
of the peak in units of the curve.
* link:#pypalmsens.data.Peak.x[*x*] (link:#float[float]) – X value of
the peak.
* link:#pypalmsens.data.Peak.y[*y*] (link:#float[float]) – Y value of
the peak.
* link:#pypalmsens.data.Peak.right_index[*right_index*] (link:#int[int])
– Left side of the peaks baseline as index number of the curve.
* link:#pypalmsens.data.Peak.right_x[*right_x*] (link:#float[float]) – X
of the right side of the peak baseline.
* link:#pypalmsens.data.Peak.right_y[*right_y*] (link:#float[float]) –
Returns the Y of the right side of the peak baseline.
* link:#pypalmsens.data.Peak.width[*width*] (link:#float[float]) – Full
width at half-height of the peak.

==== curve

[source,python]
----
curve: Curve
----

Parent curve associated with Peak.

==== curve_title

[source,python]
----
curve_title: str
----

Title of parent curve.

==== x_unit

[source,python]
----
x_unit: str
----

Units of X axis

==== y_unit

[source,python]
----
y_unit: str
----

Units for Y axis

==== analyte_name

[source,python]
----
analyte_name: str
----

Name of analyte.

==== area

[source,python]
----
area: float
----

Area of the peak.

==== label

[source,python]
----
label: str
----

Formatted label for the peak value.

==== left_index

[source,python]
----
left_index: int
----

Left side of the peaks baseline as index number of the curve.

==== left_x

[source,python]
----
left_x: float
----

X of the left side of the peak baseline.

==== left_y

[source,python]
----
left_y: float
----

Y of the left side of the peak baseline.

==== maximum_of_derivative_neg

[source,python]
----
maximum_of_derivative_neg: float
----

Maximum derivative of the negative slope of the peak.

==== maximum_of_derivative_pos

[source,python]
----
maximum_of_derivative_pos: float
----

Maximum derivative of the positive slope of the peak.

==== maximum_of_derivative_sum

[source,python]
----
maximum_of_derivative_sum: float
----

Sum of the absolute values for both the positive and negative maximum
derivative.

==== notes

[source,python]
----
notes: str
----

User notes stored on this peak.

==== y_offset

[source,python]
----
y_offset: float
----

Offset of Y.

==== index

[source,python]
----
index: int
----

Location of the peak as index number of the curve.

==== type

[source,python]
----
type: str
----

Used to determine if a peak is auto found.

==== value

[source,python]
----
value: float
----

Value of the peak in units of the curve. This is the value of the peak
height relative to the baseline of the peak.

==== x

[source,python]
----
x: float
----

X value of the peak.

==== y

[source,python]
----
y: float
----

Y value of the peak.

==== right_index

[source,python]
----
right_index: int
----

Left side of the peaks baseline as index number of the curve.

==== right_x

[source,python]
----
right_x: float
----

X of the right side of the peak baseline.

==== right_y

[source,python]
----
right_y: float
----

Returns the Y of the right side of the peak baseline.

==== width

[source,python]
----
width: float
----

Full width at half-height of the peak.

=== DeviceInfo

[source,python]
----
DeviceInfo(type, firmware, serial, id)
----

Dataclass for device information.

*Attributes:*

* link:#pypalmsens.data.DeviceInfo.type[*type*] (link:#str[str]) –
Device type
* link:#pypalmsens.data.DeviceInfo.firmware[*firmware*] (link:#str[str])
– Firmware version
* link:#pypalmsens.data.DeviceInfo.serial[*serial*] (link:#str[str]) –
Serial number
* link:#pypalmsens.data.DeviceInfo.id[*id*] (link:#int[int]) – Device ID

==== type

[source,python]
----
type: str
----

Device type

==== firmware

[source,python]
----
firmware: str
----

Firmware version

==== serial

[source,python]
----
serial: str
----

Serial number

==== id

[source,python]
----
id: int
----

Device ID

=== Curve

[source,python]
----
Curve(*, pscurve)
----

Python wrapper for .NET Curve class.

*Parameters:*

* *pscurve* (link:#PalmSens.Plottables.Curve[Curve]) – Reference to .NET
curve object.

*Functions:*

* link:#pypalmsens.data.Curve.copy[*copy*] – Return a copy of this
curve.
* link:#pypalmsens.data.Curve.smooth[*smooth*] – Smooth the .y_array
using a Savitsky-Golay filter with the specified smooth
* link:#pypalmsens.data.Curve.savitsky_golay[*savitsky_golay*] – Smooth
the .y_array using a Savitsky-Golay filter with the specified window
* link:#pypalmsens.data.Curve.find_peaks[*find_peaks*] – Find peaks in a
curve in all directions.
* link:#pypalmsens.data.Curve.find_peaks_semiderivative[*find_peaks_semiderivative*]
– Find peaks in a curve using the semi-derivative algorithm.
* link:#pypalmsens.data.Curve.clear_peaks[*clear_peaks*] – Clear peaks
stored on object.
* link:#pypalmsens.data.Curve.linear_slope[*linear_slope*] – Calculate
linear line parameters for this curve between two indexes.
* link:#pypalmsens.data.Curve.plot[*plot*] – Generate simple plot for
this curve using matplotlib.

*Attributes:*

* link:#pypalmsens.data.Curve.max_x[*max_x*] (link:#float[float]) –
Maximum X value found in this curve.
* link:#pypalmsens.data.Curve.max_y[*max_y*] (link:#float[float]) –
Maximum Y value found in this curve.
* link:#pypalmsens.data.Curve.min_x[*min_x*] (link:#float[float]) –
Minimum X value found in this curve.
* link:#pypalmsens.data.Curve.min_y[*min_y*] (link:#float[float]) –
Minimum Y value found in this curve.
* link:#pypalmsens.data.Curve.mux_channel[*mux_channel*]
(link:#int[int]) – The corresponding MUX channel number with the curve
starting at 0.
* link:#pypalmsens.data.Curve.n_points[*n_points*] (link:#int[int]) –
Number of points for this curve.
* link:#pypalmsens.data.Curve.ocp_value[*ocp_value*]
(link:#float[float]) – OCP value for curve.
* link:#pypalmsens.data.Curve.reference_electrode_name[*reference_electrode_name*]
(link:#typing.Union[Union][None, link:#str[str]]) – The name of the
reference electrode. Return None if not set.
* link:#pypalmsens.data.Curve.reference_electrode_potential[*reference_electrode_potential*]
(link:#typing.Union[Union][None, link:#str[str]]) – The reference
electrode potential offset. Return None if not set.
* link:#pypalmsens.data.Curve.x_unit[*x_unit*] (link:#str[str]) – Units
for X dimension.
* link:#pypalmsens.data.Curve.x_label[*x_label*] (link:#str[str]) –
Label for X dimension.
* link:#pypalmsens.data.Curve.y_unit[*y_unit*] (link:#str[str]) – Units
for Y dimension.
* link:#pypalmsens.data.Curve.y_label[*y_label*] (link:#str[str]) –
Label for Y dimension.
* link:#pypalmsens.data.Curve.z_unit[*z_unit*]
(link:#typing.Union[Union][None, link:#str[str]]) – Units for Z
dimension. Returns None if not set.
* link:#pypalmsens.data.Curve.z_label[*z_label*]
(link:#typing.Union[Union][None, link:#str[str]]) – Units for Z
dimension. Returns None if not set.
* link:#pypalmsens.data.Curve.title[*title*] (link:#str[str]) – Title
for the curve.
* link:#pypalmsens.data.Curve.peaks[*peaks*]
(link:#list[list][link:#pypalmsens._data.peak.Peak[Peak]]) – Return
peaks stored on object.
* link:#pypalmsens.data.Curve.x_array[*x_array*]
(link:#pypalmsens._data.data_array.DataArray[DataArray]) – Y data for
the curve.
* link:#pypalmsens.data.Curve.y_array[*y_array*]
(link:#pypalmsens._data.data_array.DataArray[DataArray]) – Y data for
the curve.

==== max_x

[source,python]
----
max_x: float
----

Maximum X value found in this curve.

==== max_y

[source,python]
----
max_y: float
----

Maximum Y value found in this curve.

==== min_x

[source,python]
----
min_x: float
----

Minimum X value found in this curve.

==== min_y

[source,python]
----
min_y: float
----

Minimum Y value found in this curve.

==== mux_channel

[source,python]
----
mux_channel: int
----

The corresponding MUX channel number with the curve starting at 0.
Return -1 when no MUX channel used.

==== n_points

[source,python]
----
n_points: int
----

Number of points for this curve.

==== ocp_value

[source,python]
----
ocp_value: float
----

OCP value for curve.

==== reference_electrode_name

[source,python]
----
reference_electrode_name: Union[None, str]
----

The name of the reference electrode. Return None if not set.

==== reference_electrode_potential

[source,python]
----
reference_electrode_potential: Union[None, str]
----

The reference electrode potential offset. Return None if not set.

==== x_unit

[source,python]
----
x_unit: str
----

Units for X dimension.

==== x_label

[source,python]
----
x_label: str
----

Label for X dimension.

==== y_unit

[source,python]
----
y_unit: str
----

Units for Y dimension.

==== y_label

[source,python]
----
y_label: str
----

Label for Y dimension.

==== z_unit

[source,python]
----
z_unit: Union[None, str]
----

Units for Z dimension. Returns None if not set.

==== z_label

[source,python]
----
z_label: Union[None, str]
----

Units for Z dimension. Returns None if not set.

==== title

[source,python]
----
title: str
----

Title for the curve.

==== peaks

[source,python]
----
peaks: list[Peak]
----

Return peaks stored on object.

==== x_array

[source,python]
----
x_array: DataArray
----

Y data for the curve.

==== y_array

[source,python]
----
y_array: DataArray
----

Y data for the curve.

==== copy

[source,python]
----
copy()
----

Return a copy of this curve.

==== smooth

[source,python]
----
smooth(smooth_level=0)
----

Smooth the .y_array using a Savitsky-Golay filter with the specified
smooth level.

*Parameters:*

* *smooth_level* (link:#int[int]) – The smooth level to be used. -1 =
none, 0 = no smooth (spike rejection only), 1 = 5 points, 2 = 9 points,
3 = 15 points, 4 = 25 points

==== savitsky_golay

[source,python]
----
savitsky_golay(window_size=3)
----

Smooth the .y_array using a Savitsky-Golay filter with the specified
window size.

(i.e. window size 2 will filter points based on the values of the
next/previous 2 points)

*Parameters:*

* *window_size* (link:#int[int]) – Size of the window

==== find_peaks

[source,python]
----
find_peaks(min_peak_width=0.1, min_peak_height=0.0, peak_shoulders=False, merge_overlapping_peaks=True)
----

Find peaks in a curve in all directions.

CV can have 1 or 2 direction changes.

*Parameters:*

* *min_peak_width* (link:#float[float]) – Minimum width of the peak in V
* *min_peak_height* (link:#float[float]) – Minimum height of the peak in
uA
* *peak_shoulders* (link:#bool[bool]) – Use alternative peak search
algorithm optimized for finding peaks on slopes
* *merge_overlapping_peaks* (link:#bool[bool]) – Two or more peaks that
overlap will be identified as a single base peak and as shoulder peaks
on the base peak.

*Returns:*

* *peak_list* (link:#list[list][link:#pypalmsens._data.peak.Peak[Peak]])
–

==== find_peaks_semiderivative

[source,python]
----
find_peaks_semiderivative(min_peak_height=0.0)
----

Find peaks in a curve using the semi-derivative algorithm.

Used for detecting non-overlapping peaks in LSV and CV curves. The peaks
are also assigned to the curve, updating `+Curve.peaks+`. Existing peaks
are overwritten.

For more info, see this
https://en.wikipedia.org/wiki/Neopolarogram[Wikipedia page].

*Parameters:*

* *min_peak_height* (link:#float[float]) – Minimum height of the peak in
uA

*Returns:*

* *peak_list* (link:#list[list][link:#pypalmsens._data.peak.Peak[Peak]])
–

==== clear_peaks

[source,python]
----
clear_peaks()
----

Clear peaks stored on object.

==== linear_slope

[source,python]
----
linear_slope(start=None, stop=None)
----

Calculate linear line parameters for this curve between two indexes.

current = a + b * x

*Parameters:*

* *start* (link:#int[int]) – begin index
* *stop* (link:#int[int]) – end index

*Returns:*

* *a* (link:#float[float]) –
* *b* (link:#float[float]) –
* *coefdet* (link:#float[float]) – Coefficient of determination (R2)

==== plot

[source,python]
----
plot(ax=None, legend=True, **plot_kwargs)
----

Generate simple plot for this curve using matplotlib.

*Parameters:*

* *ax*
(link:#typing.Optional[Optional][link:#matplotlib.axes.Axes[Axes]]) –
Add plot to this ax if specified.
* *legend* (link:#bool[bool]) – If True, add legend.
* *plot_kwargs* – These keyword arguments are passed to `+ax.plot+`.

*Returns:*

* *fig* (link:#fig.Figure[Figure]) – Matplotlib figure. Use
`+fig.show()+` to render plot.

=== Measurement

[source,python]
----
Measurement(*, psmeasurement)
----

Python wrapper for .NET Measurement class.

*Parameters:*

* *psmeasurement* (link:#PalmSens.Measurement[Measurement]) – Reference
to .NET measurement object.

*Attributes:*

* link:#pypalmsens.data.Measurement.title[*title*] (link:#str[str]) –
Title for the measurement.
* link:#pypalmsens.data.Measurement.timestamp[*timestamp*]
(link:#str[str]) – Date and time of the start of this measurement..
* link:#pypalmsens.data.Measurement.device[*device*]
(link:#pypalmsens._data.measurement.DeviceInfo[DeviceInfo]) – Return
dataclass with measurement device information.
* link:#pypalmsens.data.Measurement.blank_curve[*blank_curve*]
(link:#pypalmsens._data.curve.Curve[Curve] | None) – Blank curve.
* link:#pypalmsens.data.Measurement.has_blank_subtracted_curves[*has_blank_subtracted_curves*]
(link:#bool[bool]) – Return True if the curve collection contains a
blank subtracted curve.
* link:#pypalmsens.data.Measurement.has_eis_data[*has_eis_data*]
(link:#bool[bool]) – Return True if EIS data are is available.
* link:#pypalmsens.data.Measurement.dataset[*dataset*]
(link:#pypalmsens._data.dataset.DataSet[DataSet]) – Dataset containing
multiple arrays of values.
* link:#pypalmsens.data.Measurement.eis_data[*eis_data*]
(link:#list[list][link:#pypalmsens._data.eisdata.EISData[EISData]]) –
EIS data in measurement.
* link:#pypalmsens.data.Measurement.method[*method*]
(link:#pypalmsens._methods.method.Method[Method]) – Method related with
this Measurement.
* link:#pypalmsens.data.Measurement.channel[*channel*]
(link:#float[float]) – Get the channel that the measurement was measured
on.
* link:#pypalmsens.data.Measurement.ocp_value[*ocp_value*]
(link:#float[float]) – First OCP Value from either curves or EISData.
* link:#pypalmsens.data.Measurement.n_curves[*n_curves*]
(link:#int[int]) – Number of curves that are part of the Measurement
class.
* link:#pypalmsens.data.Measurement.n_eis_data[*n_eis_data*]
(link:#int[int]) – Number of EISdata curves (channels) that are part of
the Measurement class.
* link:#pypalmsens.data.Measurement.peaks[*peaks*]
(link:#list[list][link:#pypalmsens._data.peak.Peak[Peak]]) – Get peaks
from all curves.
* link:#pypalmsens.data.Measurement.eis_fit[*eis_fit*]
(link:#list[list][link:#pypalmsens._fitting.FitResult[FitResult]]) – Get
all EIS fits from measurement
* link:#pypalmsens.data.Measurement.curves[*curves*]
(link:#list[list][link:#pypalmsens._data.curve.Curve[Curve]]) – Get all
curves in measurement.

==== title

[source,python]
----
title: str
----

Title for the measurement.

==== timestamp

[source,python]
----
timestamp: str
----

Date and time of the start of this measurement..

==== device

[source,python]
----
device: DeviceInfo
----

Return dataclass with measurement device information.

==== blank_curve

[source,python]
----
blank_curve: Curve | None
----

Blank curve.

if Blank curve is present (not null) a new curve will be added after
each measurement containing the result of the measured curve subtracted
with the Blank curve.

==== has_blank_subtracted_curves

[source,python]
----
has_blank_subtracted_curves: bool
----

Return True if the curve collection contains a blank subtracted curve.

==== has_eis_data

[source,python]
----
has_eis_data: bool
----

Return True if EIS data are is available.

==== dataset

[source,python]
----
dataset: DataSet
----

Dataset containing multiple arrays of values.

All values are related by means of their indices. Data arrays in a
dataset should always have an equal amount of entries.

==== eis_data

[source,python]
----
eis_data: list[EISData]
----

EIS data in measurement.

==== method

[source,python]
----
method: Method
----

Method related with this Measurement.

The information from the Method is used when saving Curves.

==== channel

[source,python]
----
channel: float
----

Get the channel that the measurement was measured on.

==== ocp_value

[source,python]
----
ocp_value: float
----

First OCP Value from either curves or EISData.

==== n_curves

[source,python]
----
n_curves: int
----

Number of curves that are part of the Measurement class.

==== n_eis_data

[source,python]
----
n_eis_data: int
----

Number of EISdata curves (channels) that are part of the Measurement
class.

==== peaks

[source,python]
----
peaks: list[Peak]
----

Get peaks from all curves.

*Returns:*

* *peaks* (link:#list[list][link:#pypalmsens._data.peak.Peak[Peak]]) –
List of peaks

==== eis_fit

[source,python]
----
eis_fit: list[FitResult]
----

Get all EIS fits from measurement

*Returns:*

* *eis_fits* (link:#list[list][link:#EISFitResults[EISFitResults]]) –
Return list of EIS fits

==== curves

[source,python]
----
curves: list[Curve]
----

Get all curves in measurement.

*Returns:*

* *curves* (link:#list[list][link:#pypalmsens._data.curve.Curve[Curve]])
– List of curves

=== DataSet

[source,python]
----
DataSet(*, psdataset)
----

Python wrapper for .NET DataSet class.

*Parameters:*

* *psdataset* (link:#PalmSens.Data.DataSet[DataSet]) – Reference to .NET
DataSet object.

*Functions:*

* link:#pypalmsens.data.DataSet.curve[*curve*] – Construct a custom
curve from x and y keys.
* link:#pypalmsens.data.DataSet.arrays[*arrays*] – Return list of all
arrays. Alias for `+.to_list()+`
* link:#pypalmsens.data.DataSet.hidden_arrays[*hidden_arrays*] – Return
'`hidden`' arrays used for debugging.
* link:#pypalmsens.data.DataSet.arrays_by_name[*arrays_by_name*] – Get
arrays by name.
* link:#pypalmsens.data.DataSet.arrays_by_quantity[*arrays_by_quantity*]
– Get arrays by quantity.
* link:#pypalmsens.data.DataSet.arrays_by_type[*arrays_by_type*] – Get
arrays by data type.
* link:#pypalmsens.data.DataSet.current_arrays[*current_arrays*] –
Return all Current arrays.
* link:#pypalmsens.data.DataSet.potential_arrays[*potential_arrays*] –
Return all Potential arrays.
* link:#pypalmsens.data.DataSet.time_arrays[*time_arrays*] – Return all
Time arrays.
* link:#pypalmsens.data.DataSet.freq_arrays[*freq_arrays*] – Return all
Frequency arrays.
* link:#pypalmsens.data.DataSet.zre_arrays[*zre_arrays*] – Return all
ZRe arrays.
* link:#pypalmsens.data.DataSet.zim_arrays[*zim_arrays*] – Return all
ZIm arrays.
* link:#pypalmsens.data.DataSet.aux_input_arrays[*aux_input_arrays*] –
Return all AuxInput arrays.
* link:#pypalmsens.data.DataSet.current_range[*current_range*] – Return
current range as list of strings.
* link:#pypalmsens.data.DataSet.reading_status[*reading_status*] –
Return reading status as list of strings.
* link:#pypalmsens.data.DataSet.timing_status[*timing_status*] – Return
timing status as list of strings.
* link:#pypalmsens.data.DataSet.to_dataframe[*to_dataframe*] – Return
dataset as pandas dataframe.

*Attributes:*

* link:#pypalmsens.data.DataSet.array_types[*array_types*]
(link:#set[set][link:#pypalmsens._data._shared.ArrayType[ArrayType]]) –
Return unique set of array type (enum) for arrays in dataset.
* link:#pypalmsens.data.DataSet.array_names[*array_names*]
(link:#set[set][link:#str[str]]) – Return unique set of names for arrays
in dataset.
* link:#pypalmsens.data.DataSet.array_quantities[*array_quantities*]
(link:#set[set][link:#str[str]]) – Return unique set of quantities for
arrays in dataset.

==== array_types

[source,python]
----
array_types: set[ArrayType]
----

Return unique set of array type (enum) for arrays in dataset.

==== array_names

[source,python]
----
array_names: set[str]
----

Return unique set of names for arrays in dataset.

==== array_quantities

[source,python]
----
array_quantities: set[str]
----

Return unique set of quantities for arrays in dataset.

==== curve

[source,python]
----
curve(x, y, title=None)
----

Construct a custom curve from x and y keys.

*Parameters:*

* *x* (link:#str[str]) – Key identifying the x array
* *y* (link:#str[str]) – Key identifying the y array
* *title* (link:#str[str]) – Set the title. If None, use the
latexmath:[x-]y as title

*Returns:*

* *curve* (link:#pypalmsens._data.curve.Curve[Curve]) – New Curve with
plotting x against y

==== arrays

[source,python]
----
arrays()
----

Return list of all arrays. Alias for `+.to_list()+`

==== hidden_arrays

[source,python]
----
hidden_arrays()
----

Return '`hidden`' arrays used for debugging.

==== arrays_by_name

[source,python]
----
arrays_by_name(name)
----

Get arrays by name.

*Parameters:*

* *name* (link:#str[str]) – Name of the array.

*Returns:*

* *arrays*
(link:#list[list][link:#pypalmsens._data.data_array.DataArray[DataArray]])
–

==== arrays_by_quantity

[source,python]
----
arrays_by_quantity(quantity)
----

Get arrays by quantity.

*Parameters:*

* *quantity* (link:#str[str]) – Quantity of the array.

*Returns:*

* *arrays*
(link:#list[list][link:#pypalmsens._data.data_array.DataArray[DataArray]])
–

==== arrays_by_type

[source,python]
----
arrays_by_type(array_type)
----

Get arrays by data type.

*Parameters:*

* *array_type* (link:#str[str]) – Type of the array.

*Returns:*

* *arrays*
(link:#list[list][link:#pypalmsens._data.data_array.DataArray[DataArray]])
–

==== current_arrays

[source,python]
----
current_arrays()
----

Return all Current arrays.

==== potential_arrays

[source,python]
----
potential_arrays()
----

Return all Potential arrays.

==== time_arrays

[source,python]
----
time_arrays()
----

Return all Time arrays.

==== freq_arrays

[source,python]
----
freq_arrays()
----

Return all Frequency arrays.

==== zre_arrays

[source,python]
----
zre_arrays()
----

Return all ZRe arrays.

==== zim_arrays

[source,python]
----
zim_arrays()
----

Return all ZIm arrays.

==== aux_input_arrays

[source,python]
----
aux_input_arrays()
----

Return all AuxInput arrays.

==== current_range

[source,python]
----
current_range()
----

Return current range as list of strings.

==== reading_status

[source,python]
----
reading_status()
----

Return reading status as list of strings.

==== timing_status

[source,python]
----
timing_status()
----

Return timing status as list of strings.

==== to_dataframe

[source,python]
----
to_dataframe()
----

Return dataset as pandas dataframe.

Requires pandas.

*Returns:*

* *df* (link:#pandas.DataFrame[DataFrame]) – pandas dataframe with all
arrays in dataset

=== EISData

[source,python]
----
EISData(*, pseis)
----

Python wrapper for .NET EISdata class.

*Parameters:*

* *pseis* – Reference to .NET EISdata object.

*Functions:*

* link:#pypalmsens.data.EISData.get_data_for_frequency[*get_data_for_frequency*]
– Returns dictionary with data per frequency.
* link:#pypalmsens.data.EISData.arrays[*arrays*] – Complete list of data
arrays.
* link:#pypalmsens.data.EISData.current_range[*current_range*] – Current
ranges for the measurement.

*Attributes:*

* link:#pypalmsens.data.EISData.title[*title*] (link:#str[str]) – Tite
for EIS data.
* link:#pypalmsens.data.EISData.frequency_type[*frequency_type*]
(link:#str[str]) – Frequency type.
* link:#pypalmsens.data.EISData.scan_type[*scan_type*] (link:#str[str])
– Scan type.
* link:#pypalmsens.data.EISData.dataset[*dataset*]
(link:#pypalmsens._data.dataset.DataSet[DataSet]) – Dataset which
contains multiple arrays of values.
* link:#pypalmsens.data.EISData.subscans[*subscans*]
(link:#list[list][link:#pypalmsens._data.eisdata.EISData[EISData]]) –
Get list of subscans.
* link:#pypalmsens.data.EISData.n_points[*n_points*] (link:#int[int]) –
Number of points (including subscans).
* link:#pypalmsens.data.EISData.n_frequencies[*n_frequencies*]
(link:#int[int]) – Number of frequencies.
* link:#pypalmsens.data.EISData.n_subscans[*n_subscans*]
(link:#int[int]) – Number of subscans.
* link:#pypalmsens.data.EISData.x_unit[*x_unit*] (link:#str[str]) – Unit
for array.
* link:#pypalmsens.data.EISData.x_quantity[*x_quantity*]
(link:#str[str]) – Quantity for array.
* link:#pypalmsens.data.EISData.ocp_value[*ocp_value*]
(link:#float[float]) – OCP Value.
* link:#pypalmsens.data.EISData.has_subscans[*has_subscans*]
(link:#bool[bool]) – Return True if data contains subscans.
* link:#pypalmsens.data.EISData.mux_channel[*mux_channel*]
(link:#int[int]) – Mux channel.
* link:#pypalmsens.data.EISData.cdc[*cdc*] (link:#str[str]) – Gets the
CDC circuit for fitting.
* link:#pypalmsens.data.EISData.cdc_values[*cdc_values*]
(link:#list[list][link:#float[float]]) – Return values for circuit
description code (CDC).

==== title

[source,python]
----
title: str
----

Tite for EIS data.

==== frequency_type

[source,python]
----
frequency_type: str
----

Frequency type.

==== scan_type

[source,python]
----
scan_type: str
----

Scan type.

==== dataset

[source,python]
----
dataset: DataSet
----

Dataset which contains multiple arrays of values.

==== subscans

[source,python]
----
subscans: list[EISData]
----

Get list of subscans.

==== n_points

[source,python]
----
n_points: int
----

Number of points (including subscans).

==== n_frequencies

[source,python]
----
n_frequencies: int
----

Number of frequencies.

==== n_subscans

[source,python]
----
n_subscans: int
----

Number of subscans.

==== x_unit

[source,python]
----
x_unit: str
----

Unit for array.

==== x_quantity

[source,python]
----
x_quantity: str
----

Quantity for array.

==== ocp_value

[source,python]
----
ocp_value: float
----

OCP Value.

==== has_subscans

[source,python]
----
has_subscans: bool
----

Return True if data contains subscans.

==== mux_channel

[source,python]
----
mux_channel: int
----

Mux channel.

==== cdc

[source,python]
----
cdc: str
----

Gets the CDC circuit for fitting.

==== cdc_values

[source,python]
----
cdc_values: list[float]
----

Return values for circuit description code (CDC).

==== get_data_for_frequency

[source,python]
----
get_data_for_frequency(frequency)
----

Returns dictionary with data per frequency.

*Parameters:*

* *frequency* (link:#int[int]) – Index of the frequency to retrieve the
data for.

*Returns:*

* link:#dict[dict][link:#str[str],
link:#pypalmsens._data.data_array.DataArray[DataArray]] – Data are
returned as a dictionary keyed by the data type.

==== arrays

[source,python]
----
arrays()
----

Complete list of data arrays.

==== current_range

[source,python]
----
current_range()
----

Current ranges for the measurement.
