=== Measuring

Starting a measurement is done by sending method parameters to a
PalmSens/EmStat device. Events are raised when a measurement has been
started/ended, when a new curve/scan is started/finished, and when new
data is received during a measurement.

*Simplified PalmSens.Core:*

using PalmSens.Core.Simplified.Data;

Add these namespaces at the top of the document.

psCommSimpleWinForms.MeasurementStarted +=
PsCommSimpleWinForms_MeasurementStarted; //Raised when a measurement
begins

psCommSimpleWinForms.MeasurementEnded +=
PsCommSimpleWinForms_MeasurementEnded; //Raised when a measurement is
ended

psCommSimpleWinForms.SimpleCurveStartReceivingData +=
PsCommSimpleWinForms_SimpleCurveStartReceivingData; //Raised when a new
SimpleCurve instance starts receiving datapoints, returns a reference to
the active SimpleCurve instance

Subscribing to these events informs you on the status of a measurement
and gives you references to the active *SimpleCurve* instances.
(*psCommSimpleWinForms* is a reference to the instance of the
*psCommSimpleWinForms* component in the Form).

SimpleMeasurement activeSimpleMeasurement =
psCommSimpleWinForms.Measure(method);

This line starts the measurement described in the instance of the method
class. It returns a reference to the instance of the SimpleMeasurement,
in the case of a connection error or invalid method parameters it
returns null. Optionally, when using a multiplexer the channel can be
specified as an integer, for example *psCommSimpleWinForms.Measure
(method,2)*. (*method* is a reference to an instance of the
*PalmSens.Method* class, methods can be found in the namespace
*PalmSens.Tecnhniques* more information on methods and their parameters
is available in chapter 7).

SimpleCurve _activeSimpleCurve;

private void PsCommSimpleWinForms_SimpleCurveStartReceivingData(object
sender, SimpleCurve activeSimpleCurve)

\{

_activeSimpleCurve = activeSimpleCurve;

_activeSimpleCurve.NewDataAdded += _activeSimpleCurve_NewDataAdded;

_activeSimpleCurve.CurveFinished += _activeSimpleCurve_CurveFinished;

}

private void _activeSimpleCurve_NewDataAdded(object sender,
PalmSens.Data.ArrayDataAddedEventArgs e)

\{

int startIndex = e.StartIndex;

int count = e.Count;

double[] newData = new double[count];

(sender as SimpleCurve).YAxisValues.CopyTo(newData, startIndex);

}

private void _activeCurve_Finished(object sender, EventArgs e)

\{

_activeSimpleCurve.NewDataAdded -= _activeSimpleCurve_NewDataAdded;

_activeSimpleCurve.Finished -= _activeSimpleCurve_Finished;

}

This code shows you how to obtain a reference to the instance of the
active SimpleCurve currently receiving data from the
*SimpleCurveStartReceivingData* event. It also shows how to subscribe
this SimpleCurve’s *NewDataAdded* and *CurveFinished* events and how
these events can be used to retrieve the values of new data points from
the Simple Curve as soon as they are available.

During a measurement the property *psCommSimpleWinForms.DeviceState*
property equals either *CommManager.DeviceState.Pretreatment* or
*CommManager.DeviceState.Measurement*.

*PalmSens.Core:*

using PalmSens;

using PalmSens.Comm;

using PalmSens.Plottables;

Add these namespaces at the top of the document.

comm.BeginMeasurement += Comm_BeginMeasurement; //Raised when a
measurement begins, returns a reference to its measurement instance

comm.EndMeasurement += Comm_EndMeasurement; //Raised when a measurement
is ended

comm.BeginReceiveCurve += Comm_BeginReceiveCurve; //Raised when a curve
instance

begins receiving datapoints, returns a reference to the active curve
instance

comm.BeginReceiveEISData += Comm_BeginReceiveEISData; //Raised when a
EISData instance begins receiving datapoints, returns a reference to the
active EISData instance

Subscribing to these events informs you on the status of a measurement
and gives you the references to the active measurement and curve
instances. (*comm* is a reference to the instance of the *CommManager*
created when connecting to a device).

comm.Measure(method);

This line starts the measurement described in the instance of the method
class. Optionally, when using a multiplexer the channel can be specified
as an integer, for example *comm.Measure(method,2)*. (*method* is a
reference to an instance of the *PalmSens.Method* class, methods can be
found in the namespace *PalmSens.Techniques* more information on methods
and their parameters is available in chapter 7).

Measurement measurement;

private void Comm_BeginMeasurement(object sender, ActiveMeasurement
newMeasurement)

\{

measurement = newMeasurement;

}

When the *BeginMeasurement* event is raised it returns a reference to
the instance of the current measurement. Alternatively, this reference
can be obtained from the *CommManager.ActiveMeasurement* property after
the measurement has been started.

Curve _activeCurve;

private void Comm_BeginReceiveCurve(object sender,
PalmSens.Plottables.CurveEventArgs e)

\{

_activeCurve = e.GetCurve();

_activeCurve.NewDataAdded += _activeCurve_NewDataAdded;

_activeCurve.Finished += _activeCurve_Finished;

}

private void _activeCurve_NewDataAdded(object sender,
PalmSens.Data.ArrayDataAddedEventArgs e)

\{

int startIndex = e.StartIndex;

int count = e.Count;

double[] newData = new double[count];

(sender as Curve).GetYValues().CopyTo(newData, startIndex);

}

private void _activeCurve_Finished(object sender, EventArgs e)

\{

_activeCurve.NewDataAdded -= _activeCurve_NewDataAdded;

_activeCurve.Finished -= _activeCurve_Finished;

}

This code shows you how to obtain a reference to the instance of the
active curve currently receiving data from the *BeginReceiveCurve*
event. It also shows how to use the active curve’s *NewDataAdded* and
*Finished* events to retrieve the values of new data points from the
curve as soon as they are available.

EISData _activeEISData;

private void Comm_BeginReceiveEISData(object sender,
PalmSens.Plottables.EISData eisdata)

\{

_activeEISData = eisdata;

____
_activeEISData.NewDataAdded += _activeEISData_NewDataAdded; //Raised
when new data is added

_activeEISData.NewSubScanAdded += _activeEISData_NewSubScanAdded;
//Raised when a new frequency scan is started

_activeEISData.Finished += _activeEISData_Finished; //Raised when
EISData is finished
____

}

When performing Impedance Spectroscopy measurements data points are
stored in an instance of the *EISData* class and these events should be
used similarly to those used for other measurements.

During a measurement the property *comm.Busy* is true.

____
**Mains Frequency +
**To eliminate noise induced by other electrical appliances it is highly
recommended to set your regional mains frequency (50/60 Hz) in the
static property PalmSens.Method.PowerFreq.
____

=== MethodSCRIPT^TM^

The MethodSCRIPT^TM^ scripting language is designed to integrate our OEM
potentiostat (modules) effortlessly in your hardware setup or product.

MethodSCRIPT^TM^ allows developers to program a human-readable script
directly into the potentiostat module by means of a serial (TTL)
connection. The simple script language allows for running all supported
electrochemical techniques and makes it easy to combine different
measurements and other tasks.

More script features include:

* Use of variables
* (Nested) loops
* Logging results to an SD card
* Digital I/O for example for waiting for an external trigger
* Reading auxiliary values like pH or temperature
* Going to sleep or hibernate mode

See for more information:
https://www.palmsens.com/methodscript[www.palmsens.com/methodscript]

==== Sandbox Measurements

PSTrace includes an option to make use MethodSCRIPT^TM^ Sandbox to write
and run scripts. This is a great place to test MethodSCRIPT^TM^
measurements to see what the result would be. That script can then be
used in the MethodScriptSandbox technique in the SDK as demonstrated
below.

image:media/image10.png[Graphical user interface, application
Description automatically generated,width=604,height=459]

The following example contains 2 measurements, a LSV (meas_loop_lsv) and
a CV (meas_loop_cv). Custom MethodSCRIPT^TM^ can be run using the
MethodScriptSandbox Method class.

var methodSCRIPT = @"e

var c

var p

set_pgstat_chan 1

set_pgstat_mode 0

set_pgstat_chan 0

set_pgstat_mode 3

set_max_bandwidth 400

set_range_minmax da -1 1

set_range ba 590u

set_autoranging ba 590n 590u

cell_on

meas_loop_lsv p c -500m 500m 10m 1

pck_start

pck_add p

pck_add c

pck_end

endloop

meas_loop_cv p c -500m -1 1 10m 1

pck_start

pck_add p

pck_add c

pck_end

endloop

on_finished:

cell_off

".Replace("\r", ""); // Remove all carriage return characters

var sandbox = new MethodScriptSandbox

\{

MethodScript = methodSCRIPT 

};

As seen with the example above, MethodSCRIPT^TM^ allows multiple
measurements with a single script without having to send multiple
scripts. The script string text must not contain the default newline
characters (\r\n), these need to be replace just with the line feed or
new line character (\n).

Please see section link:#measuring[Measuring] to see how to run methods.
MethodSCRIPT^TM^ must be run on the appropriate devices. You can check
if a device is capable of running method script by casting the
capabilities to MethodScriptDeviceCapabilities.

psCommSimpleWinForms.Capabilities is MethodScriptDeviceCapabilities

SandboxMeasurements parse and store the variables sent in pcks. Curves
are generated automatically for each meas_loop that defines a pck with
two or more variables, scripts with multiple meas_loops will generate
multiple curves. The first variable in the pck will be set as the x-axis
and a curve is created for each subsequent variable in the pck. Please
note that to plot data versus time you will need to a variable with the
time to the pck.

==== Getter/Setter

The getter/setter allows you to control the IO pins of the devices that
allow this, for example with the EmStat PICO. Here a simple
getter/setter example:

*Simplified PalmSens.Core:*

Getter Example:

byte bitMask = 0b10101010; //A bitmask specifying which digital lines to read (0 = ignore, 1 = read).

//Synchronous

var result = psCommSimpleWinForms.ReadDigitalLine(bitMask);

//Asynchronous

var result = await psCommSimpleWinForms.ReadDigitalLineAsync(bitMask);

Setter Example:

byte bitMask = 0b11111111; //A bitmask specifying the output signal of the digital lines (0 = low, 1 = high).

var configGPIO = 0b10101010; //A bitmask specifying the the mode of digital lines (0 = input, 1 = output).

//Synchronous

psCommSimpleWinForms.SetDigitalOutput(bitMask, configGPIO);

//Asynchronous

await psCommSimpleWinForms.SetDigitalOutputAsync(bitMask, configGPIO);

Using MethodSCRIPT^TM^:

Setter Example:

string script = "e\nset_gpio_cfg 0b11111111 1\nset_gpio 0b10101010i\n\n";

//Synchronous

psCommSimpleWinForms.StartSetterMethodScript(script);

//Synchronous

await psCommSimpleWinForms.StartSetterMethodScriptAsync(script);

Getter Example:

string script = "e\nvar p\nset_gpio_cfg 0b11111111 0\nget_gpio p\npck_start\npck_add p\npck_end\n\n";

//Synchronous

var result = psCommSimpleWinForms.StartGetterMethodScript(script);

//Asynchronous

var result = await psCommSimpleWinForms.StartGetterMethodScriptAsync(script);

*PalmSens.Core:*

Getter Example:

string script = "e\nvar p\nset_gpio_cfg 0b11111111 0\nget_gpio p\npck_start\npck_add p\npck_end\n\n";

//Synchronous

if (Comm.ClientConnection is ClientConnectionMS connMS)

\{

string result = connMS.StartGetterMethodScript(script, timeout);

    return result;

}

//Asynchronous

if (comm.ClientConnection is ClientConnectionMS connMS)

\{

string result = await connMS.StartGetterMethodScriptAsync(script, timeout);

    return result;

}

Setter Example:

string script = "e\nset_gpio_cfg 0b11111111 1\nset_gpio 0b10101010i\n\n";

//Synchronous

if (comm.ClientConnection is ClientConnectionMS connMS)

connMS.StartSetterMethodScript(script, timeout);

//Asynchronous

if (comm.ClientConnection is ClientConnectionMS connMS)

await connMS.StartSetterMethodScriptAsync(script, timeout);

=== Disconnecting and disposing the device

The com port is *automatically closed* when the instance of the
*CommManager* is disconnected or disposed.

*Simplified PalmSens.Core:*

psCommSimpleWinForms.Disconnect(); or psCommSimpleWinForms.Dispose();

*PalmSens.Core:*

comm.ClientConnection.Run(() => comm.Disconnect()).Wait() or
comm.Disconnect(); or comm.Dispose();

The *psCommSimpleWinForms.Disconnected* event is raised when the device
is disconnected, this can be particularly useful when the device was
disconnected due to a communication error as the event also returns the
respective exception as an argument in that case.

=== Possible causes of communication issues

Communication issues can occur when certain commands are executed at the
same time, i.e. starting a measurement and triggering a read potential
at the same time will result in the device receiving commands in an
incorrect order. These issues typically arise when a timer is used, when
using multiple threads, and when invoking commands in a callback on one
on the *psCommSimpleWinForms/psMultiCommSimpleWinforms* events.

When using the simplified core wrapper communication issues are
prevented as much as possible. Using commands to control the device from
your *psCommSimpleWinForms/psMultiCommSimpleWinforms* event callbacks is
blocked, to prevent communication issues. With the asynchronous methods
it is possible to control your device from one of these callbacks as the
command will be delayed and run after completion of the previous
command, however, as it can be run at a later point in time it is
important to check whether all conditions for executing the command are
still true. This can be adjusted in the *PSCommSimple.cs* or
*PSMultiCommSimple.cs* files in the *PalmSens.Core.Simplified* project.

When using the *PalmSens.Core* directly useful aids to prevent threading
issues are the *comm.ClientConnection.Run* and
*comm.ClientConnection.Run<T>* methods. These assure the commands are
run on the correct context which prevents communication errors due to
multiple threads communicating with the device simultaneously. When
using multiple threads it is highly recommended to use these helper
methods when invoking methods that communicate with the device (i.e.
Measure, Current, Potential, CurrentRange and CellOn) from a different
thread.

Setting a value safely:

comm.ClientConnection.Run(() => \{ comm.CellOn = true; }).Wait();

or when connected to a device asynchronously

await comm.ClientConnection.RunAsync(() => comm.SetCellOnAsync(true));

Getting a value safely:

Task<float> GetPotentialTask = comm.ClientConnection.Run<float>(new
Task<float>(() => \{ return comm.Potential; }));

GetPotentialTask.Wait();

float potential = GetPotentialTask.Result;

or when connected to a device asynchronously

float potential = comm.ClientConnection.RunAsync<float>(() =>
comm.GetPotentialAsync());
